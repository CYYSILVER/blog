{"pages":[{"title":"关于我","text":"学生一枚最近才决定下来走前端方向，某一天就突然有了写博客的想法，所以就有了这个页面 联系方式 邮箱: immortal_youth@126.com QQ: 992290851 Github: https://github.com/cyysilver Bilibili: https://space.bilibili.com/5419011 平时会不定期的更新一些关于前端的知识，本人也是处于学习阶段，有自己不懂的、感觉有用的一些知识点就会记录下来，写成博客。 此博客页面已提交给google爬虫，至于baidu的话，我没有管，如果有幸你能看到我的博客的话，欢迎评论留言、提点建议什么的。 虽然我不能说我写的有多么好，但我能保证全部都是原创的内容。","link":"/blog/about/index.html"},{"title":"categories","text":"","link":"/blog/categories/index.html"},{"title":"tags","text":"","link":"/blog/tags/index.html"}],"posts":[{"title":"使用原生JS实现wrap与unwrap","text":"jquery中提供了.wrap()与.unwrap()方法下面介绍一下原生js的实现方法 使用原生JS实现wrap 创建包裹的元素 在被包裹的节点前插入元素 将该节点移入包裹节点 js代码如下 12345678var wrapper = document.createElement('div')var el = document.querySelector('.wrap-me')// 在该节点前插入wrapperel.parentElement.insertBefore(wrapper, inner)// 将该节点移入wrapperwrapper.appendChild(el) HTML代码 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"outer\"&gt; &lt;div class=\"wrap-me\"&gt;this is inner text&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;var wrapper = document.createElement('div')var el = document.querySelector('.wrap-me')// 在该节点前插入wrapperel.parentElement.insertBefore(wrapper, inner)// 将该节点移入wrapperwrapper.appendChild(el)&lt;/script&gt; 使用原生JS实现unwrap 将所有元素移出该元素 删除该元素 JS代码如下 123456789101112var wrapper = document.querySelector('.wrapper li')function unwrap(ele) { /* 父元素引用 */ const parent = ele.parentElement /* 如果存在子元素，将其移出 */ while(ele.firstChild) { parent.insertBefore(ele.firstChild, ele) } /* 删除该元素 */ parent.removeChild(ele)}unwrap(wrapper) HTML代码如下 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=5, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;ul class=\"wrapper\"&gt; &lt;li class=\"wrapper\"&gt; &lt;p&gt;I' m inside element&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;I' m outside element&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;var wrapper = document.querySelector('.wrapper li')function unwrap(ele) { const parent = ele.parentElement while(ele.firstChild) { parent.insertBefore(ele.firstChild, ele) }}unwrap(wrapper)&lt;/script&gt;","link":"/blog/articles/2019-07-02-使用原生JS实现wrap与unwrap.html"},{"title":"VscodeVim 遇到的奇葩bug","text":"bug已经提交至githubhttps://github.com/VSCodeVim/Vim/issues/3864当使用插件VscodeVim和auto rename tag，新建文件在第一行输入： 1&lt;% if(get_config(&apos;toc&apos;) === true &amp;&amp; (post.layout === &apos;page&apos; || post.layout === &apos;post&apos; )) { 输入到第三个 ‘===’ 的时候编辑器就会开始卡，输入一个字符很卡，但是能正常进行其他操作太奇葩了关掉其中任意一个插件都能够正常运行 Bub 描述 操作系统: Windows 10 1903 Vscode 插件: VscodeVim, Auto Rename Tag Vscode 版本: 1.36.0 问题: 在文件中输入以下的代码会卡住键盘不能输入，但是仍然能够使用方向键移动光标 1&lt;% if(get_config(&apos;toc&apos;) === true &amp;&amp; (post.layout === &apos;page&apos; || post.layout === &apos;post&apos; )) { 在输入第三个 “===” 会产生卡顿 卡顿后仍然能够移动光标 只有在安装过vim和auto rename tag 插件后才会有冲突 Actually I’m really confused how it would work, Are my PC broken… 说实话我真不知道这玩意的原理是什么，开始我怀疑我系统问题，后来找了几个朋友测试都这样。真实个奇葩的问题 重现bugSteps to reproduce the behavior:步骤 打开Vscodej 按Ctrl+Shift+P 打开command line 输入ext: disable all 选择 Extensions: Disable All Installed Extensions 点击左侧插件 安装 vim 和 auto rename tag 插件 (两个都得启用) 创建新文件命名为 “test” (命名随便) 打开文件, 按i进入vim插入模式 输入以下的代码 *(! 注意不能忽视空格 ) *&lt;% if(get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post' )) { Expected behavior当输入到第三个 “===” 的时候就会开始卡顿 会明显感受到输入延迟, 有种打不动字的感觉 当完成输入后, 按backspace退格也会产生相同的感觉 卡顿时可能无法输入任何文字, 但能够使用方向键移动 Screenshots 运行环境 Running Extensions Node Debug Auto-attach Emmet Git Merge Conflict Auto Rename Tag 0.1.0 Vim Extension (VsCodeVim) version: 1.8.1 VSCode version: 1.36.0 OS: Windows 10 1903 提交原文Describe the bug System: Windows 10 1903 Vscode Plugins: VscodeVim, Auto Rename Tag Vscode Version: 1.36.0 bug: type the following code in a line will likely freeze your keyboard but you still can move caret with arrow key. 1&lt;% if(get_config(&apos;toc&apos;) === true &amp;&amp; (post.layout === &apos;page&apos; || post.layout === &apos;post&apos; )) { You will get stuttering when you type to the third “===” You can still move your caret when you get stuttering You can only produce the behavior when you installed both vim and auto rename tag extensions Actually I’m really confused how it would work, Are my PC broken… To ReproduceSteps to reproduce the behavior: Open Vscode Press Ctrl+Shift+P open command line Type ext: disable all Select Extensions: Disable All Installed Extensions Go to Extensions Install vim and auto rename tag (both should be enabled) Create a new file named “test” In the file, press i enter the vim insert mode Type the following code (! Can not ignore spaces)&lt;% if(get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post' )) { Expected behaviorWhen reach the third “===” stuttering would occur you can continue type but it feel lag and stutter when you finished and press backspace produce the same behavior you may can’t type any word but you can still move your caret with arrow key Screenshots Environment Running Extensions Node Debug Auto-attach Emmet Git Merge Conflict Auto Rename Tag 0.1.0 Vim Extension (VsCodeVim) version: 1.8.1 VSCode version: 1.36.0 OS: Windows 10 1903","link":"/blog/articles/2019-07-05-VscodeVim-bug.html"},{"title":"使用gulp优化hexo博客，对资源进行压缩","text":"hexo生成出来的资源文件很大，全是没有压缩的，为了节约网络带宽，可以对其public目录下的js，html，css文件进行压缩。那么这里使用的工具就是强大的gulp 使用gulp对打包出的css、js、html及图片文件进行压缩 使用hexo generate指令后，会在根目录下生成网页的资源文件其目录结构如下 查看里面的内容，会发现有大量的空白 查看文件的大小:50kb 然后我们再来看看压缩后的文件大小:33kb 内容 这些多余的空白造成了文件内容冗余，造成了空间浪费，压缩后的文件都快比原来少一半了。 gulp介绍什么是gulp？ 官网介绍:Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务的 Gulp 文件都是通过 JavaScript（或者 CoffeeScript ）源码来实现的。 想要了解更多可以查看gulp官网 准备工作 没有安装npm的需安装npm 安装gulp工具 全局安装1 npm install --global gulp 12 - 作为依赖本地安装 1npm install --save-dev gulp使用方法 在项目根目录下创建gulpfile.js的文件夹 输入以下代码 12345var gulp = require('gulp');gulp.task('default', function() {// 要执行的任务}); 然后在命令行输入 gulp 就会运行task里面的任务 如果任务名字不是default，如 12345var gulp = require('gulp')gulp.task('hello', function() { console.log('你好')}) 这时需要在命令行输入 gulp hello 输出 123[00:53:12] Using gulpfile D:\\SILVER\\Documents\\GitHub\\MyHexoBlog\\gulpfile.js[00:53:12] Starting &apos;hello&apos;...你好 简短介绍后，下面进入正题 压缩文件gulp是通过插件来运作的 首先需要安装插件 123456npm install gulp-htmlclean // 压缩htmlnpm install gulp-htmlmin // 压缩html，外加去除注释，压缩css，删除多余属性等npm install gulp-clean-css // 压缩cssnpm install gulp-uglify // 压缩jsnpm install gulp-babel // 转换为es2015npm install gulp-imagemin // 压缩图片 编写gulpfile.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182let gulp = require('gulp')let cleanCSS = require('gulp-clean-css')let htmlmin = require('gulp-htmlmin')let htmlclean = require('gulp-htmlclean')let babel = require('gulp-babel') /* 转换为es2015 */let uglify = require('gulp-uglify')let imagemin = require('gulp-imagemin')// 压缩html// 设置根目录const root = './public'// 匹配模式， **/*代表匹配所有目录下的所有文件const pattern = '**/*'gulp.task('minify-html', function() { return gulp // 匹配所有 .html结尾的文件 .src(`${root}/${pattern}.html`) .pipe(htmlclean()) .pipe( htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true }) ) .pipe(gulp.dest('./public'))})// 压缩cssgulp.task('minify-css', function() { return gulp // 匹配所有 .css结尾的文件 .src(`${root}/${pattern}.css`) .pipe( cleanCSS({ compatibility: 'ie8' }) ) .pipe(gulp.dest('./public'))})// 压缩jsgulp.task('minify-js', function() { return gulp // 匹配所有 .js结尾的文件 .src(`${root}/${pattern}.js`) .pipe( babel({ presets: ['env'] }) ) .pipe(uglify()) .pipe(gulp.dest('./public'))})// 压缩图片gulp.task('minify-images', function() { return gulp // 匹配public/images目录下的所有文件 .src(`${root}/images/${pattern}`) .pipe( imagemin( [ imagemin.gifsicle({ optimizationLevel: 3 }), imagemin.jpegtran({ progressive: true }), imagemin.optipng({ optimizationLevel: 7 }), imagemin.svgo() ], { verbose: true } ) ) .pipe(gulp.dest('./public/images'))})// 如果使用的是gulp 4.0版本以下，使用下面的代码// gulp.task('default', [// 'minify-html','minify-css','minify-js'// ]);gulp.task('default', gulp.series('minify-html', 'minify-css', 'minify-js')) 注意这里使用了gulp 4.0以上的版本 使用下面代码定义指令gulp的任务队列 12// 顺序执行 minify-html -&gt; minify-css -&gt; minify-jsgulp.task('default', gulp.series('minify-html', 'minify-css', 'minify-js')) 然后在命令行输入 gulp就可以开始压缩了 12345678910$ gulp[01:09:51] Using gulpfile D:\\SILVER\\Documents\\GitHub\\MyHexoBlog\\gulpfile.js[01:09:51] Starting &apos;default&apos;...[01:09:51] Starting &apos;minify-html&apos;...[01:09:52] Finished &apos;minify-html&apos; after 924 ms[01:09:52] Starting &apos;minify-css&apos;...[01:09:52] Finished &apos;minify-css&apos; after 65 ms[01:09:52] Starting &apos;minify-js&apos;...[01:09:53] Finished &apos;minify-js&apos; after 1.16 s[01:09:53] Finished &apos;default&apos; after 2.16 s 压缩完成后使用hexo部署 1hexo deploy 一个命令搞定生成文件，压缩，部署在package.json文件中的”scripts”下添加 123\"scripts\": { \"deploy\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d\"} 然后在控制台输入 1npm run deploy 就会开始自动生成文件-&gt;压缩文件-&gt;部署到服务器","link":"/blog/articles/2019-07-05-hexo博客优化-gulp压缩-提高访问速度.html"},{"title":"webpack入门(1): 核心概念","text":"介绍webpack 是一个用于编译Javascript模块的工具，在安装webpack之后，可以通过 CLI (command line interface 就是在控制台上使用 ) API (在js中导入模块使用) 在使用webpack之前，如果你还是一个新手，请阅读下面的核心概念之后，再进行操作 如果你想直接进入操作来学习，请进入 webpack入门之安装与使用 核心概念webpack 本质上就是个 静态模块打包器(module bundler)。webpack处理程序时会创建依赖关系图，把你应用程序中用到的文件打包成一个或者多个文件 *这里可以了解更多关于 JavaScript 模块和 webpack 模块的信息* 从4.0.0版本之后，使用webpack不需要再创建一个配置文件 以下介绍几个核心概念 Entry (入口) Output (出口) Loaders Plugins (插件) Mode Browser Compatibility (浏览器兼容性) Entry 入口入口表示你的webpack打包开始的文件，它会寻找该文件依赖的其他文件，将他们合并打包。 可以通过webpack config中的entry属性，来定义一个（或者多个起点） 默认值为./src/index.js webpack.config.js 123module.exports = { entry: './path/to/my/entry/file.js'}; Output 出口即打包后完成文件输出的目录 默认输出js为./dist/main.js 其他文件在./dist webpack.config.js 1234567891011const path = require('path');module.exports = { entry: './path/to/my/entry/file.js', output: { /* 指定输出目录 */ path: path.resolve(__dirname, 'dist'), /* 指定输出文件名 */ filename: 'my-first-webpack.bundle.js' }}; 使用output.filename和output.path来指定文件名和路径 顶部引入的const path = require('path')是Node.js用于操作文件路径的模块 Loaderswebpack本身只能处理Javascript，使用loader可以让webpack让其他类型文件转换为webpack能够处理的模块 loader 能够import 导入任何类型的模块（例如.css 文件），这是 webpack 特有的功能 loader在webpack中配置如下 webpack.config.js 12345678910111213141516const path = require('path');const config = { output: { filename: 'my-first-webpack.bundle.js' }, module: { rules: [ /* test 正则表达式，用于匹配进行转换的文件 */ /* use 表示所使用的loader名称 */ { test: /\\.txt$/, use: 'raw-loader' } ] }};module.exports = config; 以上代码中添加了module，在内部定义了rules，里面必须包含 test 属性，(正则表达式) 用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，使用的loader名称 它们的作用是告诉webpack编译器，在解析时发现 import xxxx.txt / require(xxx.txt) 里面有.txt的路径时，使用raw-loader进行转换 Plugins 插件插件与Loader不同的是，插件可用于执行范围更广的任务，具体是什么个东西在使用webpack之后就会渐渐了解 Plugins的配置如下 12345678910111213141516const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const config = { module: { rules: [ { test: /\\.txt$/, use: 'raw-loader' } ] }, plugins: [ /* 实例化一个对象 */ new HtmlWebpackPlugin({template: './src/index.html'}) ]};module.exports = config; 这里使用了一个叫做html-webpack-plugin的插件 首先在config里添加 123456const config = { /* ... */ plugins: [ /* ... */ ]}; 然后导入HtmlWebpackPlugin插件 1const HtmlWebpackPlugin = require('html-webpack-plugin'); 在config里new 一个实例 12345const config = { plugins: [ new HtmlWebpackPlugin({template: './src/index.html'}) ]}; 模式webpack有两种模式 development production 及开发模式和生产模式了解更多 浏览器兼容性webpack 支持所有支持ES5的浏览器(IE8 及以下不支持)如果你想支持旧版浏览器，你需要加载polyfill","link":"/blog/articles/2019-07-16-webpack-tutorial-01.html"},{"title":"Html+css+js布局设计第一弹","text":"8 Horizontal Menu2019/6/23水平菜单栏有一些简单的动画，在别的地方看见的，就照着做了下 1234567891011121314151617181920212223/* 主要也是用的 :before 伪元素来修饰图标 */nav .menu ul li:hover i:before { border-color: transparent; border-radius: 500px; width: 66px; height: 66px; line-height: 60px; transition: color 0.2s linear 0s, font-size 0.2s linear 0s, border-color 0.2s linear 0s, height 0.2s linear 0s, width 0.2s linear 0s, line-height 0.2s linear 0s;}nav .menu a i:before { border: 2px solid; border-color: #a3a7ad; border-radius: 500px; width: 41px; display: inline-block; height: 41px; line-height: 37px; transition: color 0.2s linear 0s, font-size 0.2s linear 0s, border-color 0.2s linear 0.2s, height 0.2s linear 0s, width 0.2s linear 0s, line-height 0.2s linear 0s;} 7 Responsive Design2019/6/21响应式卡片 12345678/* 图片使用绝对定位 *//* 使用odd 和 even 调整图片的位置 */.container .box:nth-child(odd) .thumb { bottom: 0;}.container .box:nth-child(even) .details { bottom: 0;} 响应式部分1234567891011@media (max-width: 1000px) { .container { width: 100%; height: auto; padding: 20px; box-sizing: border-box; } .container .box { height: 250px; }} 12345678910@media (max-width: 768px) { .container { flex-wrap: wrap; } .container .box { flex-basis: 50%; transition: transform 1s; }} 12345@media (max-width: 500px) { .container .box { flex-basis: 100%; }} 6 CSS 3d Layered Image2019/6/19鼠标 hover 出现特效 123/* 使用skew产生形变 */transform: rotate(-30deg) skew(25deg) scale(0.8);/* 添加4层layer，分别在hover的时候tranform就行了 */ 12345678910111213141516&lt;img src=\"res/CSS 3d Layered Image Hover Effects - CSS Isometric Design/screen.png\" alt=\"\"/&gt;&lt;img src=\"res/CSS 3d Layered Image Hover Effects - CSS Isometric Design/screen.png\" alt=\"\"/&gt;&lt;img src=\"res/CSS 3d Layered Image Hover Effects - CSS Isometric Design/screen.png\" alt=\"\"/&gt;&lt;img src=\"res/CSS 3d Layered Image Hover Effects - CSS Isometric Design/screen.png\" alt=\"\"/&gt; 123456789101112131415161718192021/* 每一张图片transform不同距离 *//* 给上不同透明度 */.container:hover img:nth-child(4) { transform: translate(160px, -160px); opacity: 1;}.container:hover img:nth-child(3) { transform: translate(120px, -120px); opacity: 0.8;}.container:hover img:nth-child(2) { transform: translate(80px, -80px); opacity: 0.6;}.container:hover img:nth-child(1) { transform: translate(40px, -40px); opacity: 0.4;} 5 Thanos Snap Disperison2019/6/18灭霸响指消失特效（有点 low） 1/* 原理就是使用一张noise.png的噪点图覆盖原图 */ 4 Hover expand menn2019/6/10简单的菜单栏 使用:target伪类来实现点击、未使用js 123456789/* * target为地址栏中的hash * 该用法能够使.item id=hash值的元素被选中 * 然后使他的高度为10em*/.item:target .submenu { max-height: 10em; /* overflow: scroll; */} 1-3 flex布局简单尝试2019/5/30flex布局11234567891011121314/* * flex中居中的方法 */.container { display: flex; justify-content: center; /* 在轴的方向上使元素居中 */ align-items: center; /* 垂直于flex轴居中 */ align-content: center; /* 设置了flex-wrap后，使得每一行居中于该行*/}/* * 注意 align-self 与 align-items 的取别 * align-self用于容器中的元素 * align-items用于容器 */ flex布局2 flex布局3 0 Glowing Border渐变色的边框2019/5/25该方法的巧妙之处是使用了为元素:after和:before来添加边框1234567891011121314151617181920212223242526.container:before { content: ''; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px; background-color: white; z-index: -1;}.container:after { content: ''; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px; background-color: white; z-index: -1; filter: blur(15px);}.container:before,.container:after { background: linear-gradient(235deg, #d4ffa2, #f956ff, #6aeeff);}","link":"/blog/articles/2019-07-03-html-css小技巧第一弹.html"},{"title":"webpack入门(2): 安装与使用","text":"下面就来通过例子讲解webpack的安装，基本操作 webpack 是一个用于编译Javascript模块的工具，在安装webpack之后，可以通过 CLI (command line interface 就是在控制台上使用 ) API (在js中导入模块使用) 下面介绍的是webpack-cli的使用 安装输入下面指令，意思是 创建webpack-demo文件夹 进入webpack-demo 初始化npm -y参数表示自动输入yes 安装webpack 安装webpack-cli 12345mkdir webpack-democd webpack-demonpm init -ynpm install webpack --save-devnpm install webpack-cli --save-dev 执行完之后会生成一个package.json，这是npm生成的文件，定义了这个项目所需要的各种模块,以及项目的配置信息。关于npm和package.json这里不做过多阐述 如果你想要了解 package.json 内在机制的更多信息，推荐阅读 npm 文档。 创建文件创建以下目录结构 12345 webpack-demo |- package.json+ |- index.html+ |- /src+ |- index.js 各个文件的内容如下./src/index.js 12345678910function component() { const element = document.createElement('div'); // Lodash（目前通过一个 script 脚本引入）对于执行这一行是必需的 element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element;}document.body.appendChild(component()); ./index.html 12345678910&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;script src=\"https://unpkg.com/lodash@4.16.6\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"./src/index.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ./package.json 123456789101112131415161718 { \"name\": \"webpack-demo\", \"version\": \"1.0.0\", \"description\": \"\",+ \"private\": true, - \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"webpack\": \"^4.20.2\", \"webpack-cli\": \"^3.1.2\" }, \"dependencies\": {} } private的作用是防止项目被发布 在开始使用webpack前，观察目录结构，默认情况下webpack的入口是src/index.js，index.js的执行需要依赖lodash 这在index.html体现出来， 1&lt;script src=\"https://unpkg.com/lodash@4.16.6\"&gt;&lt;/script&gt; 在index.js引入之前引入了lodash 但index.js未显式声明引入lodash，这时webpack会假定存在全局变量 _ lodash这个库的使用方式就是用 _操作，与jquery的$类似 不过这样做会有一些问题 无法立即体现，脚本的执行依赖于外部扩展库(external library)。 如果依赖不存在，或者引入顺序错误，应用程序将无法正常运行。 如果依赖被引入但是并没有使用，浏览器将被迫下载无用代码。 这时候执行 这句话意思是，执行安装在node_module的webpack控制台程序 1npx webpack 生成的文件中不会有lodash的变量_，将会报错 下面src/index.js通过webpack打包后生成的文件，默认在dist目录下 这里只有main.js 通过查看里面也没有lodash的脚本 index.html也不存在 显然我们这不是我们预期的输出 调整这里需要手动将index.html移入dist文件夹 更改script标签 123456789&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;起步&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这里删除了两个script标签，引入了main.js 1234567891011 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt;- &lt;script src=\"https://unpkg.com/lodash@4.16.6\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;- &lt;script src=\"./src/index.js\"&gt;&lt;/script&gt;+ &lt;script src=\"main.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 不过这里的main.js仍然没有引入lodash 这时候执行 1npx webpack 访问index.html查看控制台 可以看出 _没有被定义 通过npm安装lodash并通过import引入通过npm 安装lodash 1npm install --save lodash 引入到index.js 只是在第一行增加了import _ from 'lodash'; 123456789101112import _ from 'lodash';function component() { var element = document.createElement('div'); // Lodash 通过import引入 element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element; } document.body.appendChild(component()); 现在，可以打包我们的程序了 1npx webpack 执行安装在node_module的webpack控制台程序 查看页面 这说明代码已经执行，现在已经没问题了 使用配置文件这时我们已经基本了解webpack的工作流程，不过大多数情况下，都要通过webpack.config.js配置文件来控制webpack文件的入口，出口，需要用到的loader、插件 该内容将在下一章进行讲解","link":"/blog/articles/2019-07-16-webpack-tutorial-02-getting-start.html"},{"title":"webpack入门(3): 使用配置文件webpack.config.js及多入口的配置","text":"如果想修改webpack的默认入口，出口，使用的插件，loader时，可以通过控制台的webpack指令传入参数 如 1webpack --entry xxxx 来定义入口文件 但是更多的做法是创建一个webpack.config.js文件，利用这个文件对进行相关的配置 下面介绍使用webpack.config.js的基本配置以及多 使用webpack.config.js创建方式 可以手动新建文件， 也可以使用npx webpack init指令初始化配置文件 使用npx webpack init命令 在输入指令后根据提示创建配置文件 1234567891011npx webpack initi INFO For more information and a detailed description of each question, have a look at: https://github.com/webpack/webpack-cli/blob/master/INIT.mdi INFO Alternatively, run \"webpack(-cli) --help\" for usage info? Will your application have multiple bundles? No? Which will be your application entry point? src/index? In which folder do you want to store your generated bundles? dist? Will you use one of the below JS solutions? ES6? Will you use one of the below CSS solutions? CSS? Overwrite src\\index.js? overwrite 手动创建webpack.config.js 在项目根目录创建webpack.config.js 编辑文件 webpack.config.js 使用module.exports暴露模块 entry 定义入口文件 output 定义输出文件 plugins 使用的插件 module 使用的loader 12345678910111213141516171819202122232425262728const path = require('path');module.exports = { // 使用开发者模式 mode: 'development', // 定义入口 entry: './src/index.js', // 定义输出文件 output: { filename: 'main.js', path: path.resolve(__dirname, 'dist') }, /* // 定义插件 plugins: [new webpack.ProgressPlugin(), new HtmlWebpackPlugin()], // 定义loader module: { rules: [ { test: /\\.css$/i, use: ['style-loader', 'css-loader'], }, ], }, */}; 配置好之后运行npx webpack 输出 配置多个入口入口 这里使用3个js文件 webpack.config.js 12345678910111213module.exports = { // 使用对象语法定义3个入口文件 entry: { pageOne: './src/index1.js', pageTwo: './src/index2.js', pageThree: './src/index3.js' }, // 分别输出3个js文件，[name]表示对应的文件名 output: { filename: '[name].js', path: __dirname + '/dist' }}; 运行npx webpack 输出","link":"/blog/articles/2019-07-16-webpack-tutorial-03-config.html"},{"title":"webpack入门(4): loader的使用，style-loader，css-loader","text":"本篇文章会教你如何上手webpack的loader，以使用style-loader 、css-loader为例子 下面就正式开始吧 准备工作css-loader和style-loader的作用 css-loader能够解析css style-loader能够将导入的css自动添加进html文档 安装安装style-loader和css-loader 12npm install --save-dev style-loader npm install --save-dev css-loader 添加文件为了做演示，这里写了一个简单的css文件，配合入口文件index.js style.css 1234567891011121314* { padding: 0; margin: 0;}body { background: darkblue; height: 100vh;}p { color: red;} 在index.js中导入这个样式表 index.js 123import './style.css'document.body.innerHTML = '&lt;p&gt;hello world&lt;/p&gt;' 目录结构 开始打包这时候我们还没有安装loader，webpack只会认识js文件，如果有import其他文件，解析就会发生错误 这里提示 12odule parse failed: Unexpected token (1:0)You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. 就是因为在index.js中我们导入了style.css导致webpack不能正确解析其内容，这时候我们的loader就派上用场了 在webpack.config.js中添加以下配置项 1234567891011121314151617181920212223const path = require('path');const webpack = require('webpack');module.exports = { mode: 'development', entry: 'src/index.js', output: { filename: '[name].js', path: __dirname + '/dist' }, module: { rules: [ { test: /\\.css$/, //文件类型 use: [ { loader: \"style-loader\" }, //使用loader处理，顺序相反 { loader: \"css-loader\" }, ], }, ], },} 这里使用了module选项， 使用rule添加规则 test属性表示要处理的文件类型，用正则表达式进行匹配 use表示所使用的loader，顺序相反，这里的写法就是先使用css-loader再使用style-loader 输入指令npm run build开始打包 1234567891011Hash: d47ac130136c47b10f70Version: webpack 4.37.0Time: 269msBuilt at: 08/12/2019 2:09:12 PM Asset Size Chunks Chunk Namesmain.js 24 KiB main [emitted] mainEntrypoint main = main.js[./node_modules/css-loader/dist/cjs.js!./src/style.css] 296 bytes {main} [built][./src/index.js] 69 bytes {main} [built][./src/style.css] 1.06 KiB {main} [built] + 3 hidden modules 上面显示成功打包模块index.js和style.css 这时候在dist目录输出了main.js 我们在index.html引入main.js 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;hell world&lt;/p&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开查看效果 可以看见导入的css发挥了作用 查看head标签 可以看见打包后的main.js自动为我们生成了样式表文件 更高级的使用方法一般loader的使用还会有很多的配置选项，如何查看这些选项呢。 授人以鱼不如授之以渔 首先我们进入webpack官网，找到loader列表，然后找到css-loader 进入它的git仓库 在这里能看见很多关于此loader的介绍 比如这里有一个选项叫做modules 我们照着它的文档说明，添加此选项，看看有啥效果 下面在css-loader中添加了options属性，设置modules： true 123456789101112131415161718192021222324252627const path = require('path')const webpack = require('webpack')module.exports = { mode: 'development', entry: './src/index.js', output: { filename: '[name].js', path: __dirname + '/dist' }, module: { rules: [ { test: /\\.css$/, use: [ { loader: 'style-loader' }, { loader: 'css-loader', options: { modules: true //使用modules选项 } } ] } ] }} 更改css和js css 123.test { color: red;} **js** 123import style from './style.css'document.body.innerHTML = `&lt;p class=\"${style.test}\"&gt;hello world&lt;/p&gt;`= 这里我们import了style，然后使用了给p元素的class设置成了style.test 查看结果 可以看到.test选择器的确起了作用，不过class变成了随机生成的字符串，这就是modules选项的作用，它让样式表模块化。内部的.test选择器不会影响到外部。 再比如查阅文档下面的介绍 发现modules选项可以是Object，这样打包出来的结果 class命名方式就是[path][name]__[local]--[hash:base64:5]这样以文件路径，名称，hash值组合的方式命名 学会了吗，如果自己想使用其他的loader、不妨自己动手查查文档吧，这篇文章的目的就是带你入门。与其百度、谷歌这个怎么弄那个怎么弄，不如自己动手查一下文档。不过也得先攻破英语这关，如果你英语水平还行的话，相信我，看得足够多自然而然就能看懂，而且能够提高自己的英文水平。","link":"/blog/articles/2019-07-17-webpack-tutorial-04-use-cssloader.html"},{"title":"ES6新特性之Map、Set与WeakMap、WeakSet的区别","text":"ES6提供了新的数据结构Set，类似于数组，不过里面不会出现重复的值 另外一个是Map，类似于对象，对象只能使用字符串作为键，而Map可以使用任意类型 回顾下Map和Set 简要总结如下： Map 与 Object 一样，本质上是Hash结构 可以使用各种类型作为key Object 只能使用字符串作为key 12345678910111213// 使用数组作为keylet o = [1,2,3]let b = [1,2,3]let map = new Map()map.set(o, 'foo')map.set(b, 'bar')// 虽然使用了相同的数组，但数组的内存地址不一样，所以key不一样console.log(map.get(o)) // 'foo'console.log(map.get(b)) // 'bar'// 而使用对象就不能用上面的方法，对象的key只能使用字符串let obj = { [1,2,3]: 'foo' //会报语法错误} Set 与数组类似 成员唯一，没有重复值 12345678910let set = new Set([1,1,1,2,3,4])for (let item of set) { console.log(item)}// 1// 2// 3// 4// 去掉了重复的1 WeakMap和WeakSet与Map和Set的主要区别就是： WeakSet 对象中只能存放对象引用，不能存放原始数据（如数字 1) WeakSet 对象中存储的对象值都是被弱引用的，如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉。 WeakMap 中的key只是对象引用，不能是 原始数据类型 WeakMap 持有的是每个键或值对象的弱引用，如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉。 WeakMap 的key和 WeakSet 的元素是不可枚举的，因为他们存储的对象都是被弱引用的，如果能被枚举，会受垃圾回收机制的影响出现不确定性的结果 举个例子 如果使用的是Map 123const div = document.querySelector('div')let map = new Map()map.set(div, 'foo') 上面div是一个对象，map中以div为key，形成了对div对象的引用 如果我们不再需要这个对象，就必须手动解除引用，不然就不会对div的内存进行清理 12div = null // 不再需要这个对象map.delete(div) // 手动解除map中的引用 而如果使用了WeakMap 123const div = document.querySelector('div')let weakmap = new WeakMap()weakmap.set(div, 'foo') 如果我们不再需要这个对象，由于WeakMap是弱引用，所以垃圾回收机制会清理掉div的内存 12div = null // 不再需要这个对象// weakmap.delete(div) 不用手动解除","link":"/blog/articles/2019-07-26-WeakSet-WeakMap.html"},{"title":"javascript性能优化之debounce与throttle","text":"消抖(debounce): 当函数被调用后，n秒之后才会触发该函数，如果在此期间函数再次被调用，则重新开始计时，n秒之后才会触发该函数。 其作用是为了避免某个事件在短时间内连续触发从而影响性能，也可用于避免在一定时间内重复提交表单等。 节流(throttle): 函数被调用后，立即触发该函数，在之后的n秒之内不能再次重复触发。 该函数可以用于限制浏览器scroll，mousemove等高频触发事件的触发频率 下面介绍debounce和throttle的实现方式 这两种方法在lodash里已经给封装好了，下面用原生js实现 debounce利用闭包，设置一个timer： 每次执行都clearTimeout(timer) 每次执行设置timer = setTimeout()执行函数 1234567891011121314151617function debounce(func, delay) { // 存储timer let timer = null return function() { // 如果已经设置了 timer，将其清空，防止未执行的timer执行 clearTimeout(timer) timer = setTimeout(()=&gt; { // delay后执行函数，使用es6语法，给函数传入参数 let args = Array.from(arguments) // 传入this和参数 func.apply(this, args) }, delay) }} debounce实例在input事件使用debounce，减少触发次数，这里设置延迟为1秒，是不是有点像搜索引擎的提示呈现 代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" placeholder=\"debounce\"/&gt; &lt;p&gt;debounce test&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;const input = document.querySelector('input')const p = document.querySelector('p')input.addEventListener('input', debounce(function(e){ p.innerText = e.target.value}, 1000))function debounce(func, delay) { // 存储timer let timer = null return function() { // 如果已经设置了 timer，将其清空，防止未执行的timer执行 clearTimeout(timer) timer = setTimeout(()=&gt; { // delay后执行函数，使用es6语法，给函数传入参数 let args = Array.from(arguments) // 传入this和参数 func.apply(this, args) }, delay) }}&lt;/script&gt; codepen See the Pen debounce by Chen Yinyi (@CYSILVER) on CodePen. throttle利用闭包，设置一个exec记录当前函数执行状态： 若正则执行，则跳过if，直接退出函数 若没有在执行，则执行函数，设置exec为true，一段时间后置为false 1234567891011121314151617181920function throttle(func, delay) { // 记录当前函数是否正在被执行 let exec = false return function() { // 如果该函数未在执行 if (!exec){ // 执行该函数 let args = Array.from(arguments) func.apply(this, args) // 设置执行为true exec = true // 在delayh后设置为false setTimeout(()=&gt;{ exec = false }, delay) } }} throttle实例这里同样使用上面的例子，看看有什么区别 使用throttle，设置1秒只能触发一次 如果还看不出区别，请看下图 使用debounce ，设置延迟为1秒 很明显了对吧 不过throttle一般不用于这里，一般用于scroll，mousemove等触发频率很高的事件，对其进行限制 codepen See the Pen throttle by Chen Yinyi (@CYSILVER) on CodePen. 以上就是对debounce和throttle的介绍，希望能帮助到大家","link":"/blog/articles/2019-07-28-debounce.html"},{"title":"es6中Promise.all、Promise.race的实现及其用法","text":"灵魂配图 在es6中，新增了Promise对象 其中有两个方法 Promise.all() Promise.race() 都是用于将多个Promise实例包装成另一个实例 下面我会对两种方法进行介绍，以及自己使用js实现他们的方法 Promise.all()接受一个数组，返回Promise对象： let p = Promise.all([p1, p2, p3]) 当p1,p2,p3的状态都变为fulfilled，其p的状态才变为fulfilled。p1,p2,p3的resolve值组成数组传递给p的resolve值 p1,p2,p3中有一个状态变为rejected，那么p的状态变为rejected，reject的值为该promise的reject值 看个例子就懂了如下面代码，Promise.all的resolve值为['p1', 'p2'] 1234567891011121314151617let p1 = new Promise((resolve) =&gt; { // 模拟异步 setTimeout(() =&gt; { resolve('p1') }, 3000)})let p2 = new Promise((resolve) =&gt; { // 模拟异步 setTimeout(() =&gt; { resolve('p2') }, 2000)})Promise.all([p1, p2]).then((res) =&gt; { console.log(res) // 输出['p1', 'p2']}) 123456789let p3 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject('p3') }, 1500)})Promise.all([p2, p3]).then(null, (res) =&gt; { console.log(res) // 输出'p3'}) 实现方式代码如下，要点都写在注释里了 1234567891011121314151617181920212223242526function PromiseAll(arr) { // 把每个resolve的结果存放在result let result = [] // 记录arr的长度 let length = arr.length let curlength = 0 return new Promise((resolve, reject) =&gt; { arr.forEach((p, index) =&gt; { // 使用 Promise.resolve()将不是Promise对象转换为Promise对象 // 调用每一个promise对象的then方法 Promise.resolve(p).then((res) =&gt; { // 调用之后将结果存入result result[index] = res curlength++ // 判断是否全部执行完毕 if (result.length === curlength) { resolve(result) } // 如果出错，直接reject }, (err) =&gt; { reject(err) }) }); })} Promise.race()接受一个数组，返回Promise对象： let p = Promise.race([p1, p2, p3]) 当p1,p2,p3中最先变为fulfill或者rejected的Promise对象的reject或resolve值，就为p的reject或resolve值 看个例子就懂了下面代码p2状态更快变为fulfilled输出值为p2 1234567891011121314151617let p1 = new Promise((resolve) =&gt; { // 模拟异步 setTimeout(() =&gt; { resolve('p1') }, 3000)})let p2 = new Promise((resolve) =&gt; { // 模拟异步 setTimeout(() =&gt; { resolve('p2') }, 2000)})Promise.race([p1, p2]).then((res) =&gt; { console.log(res) // 'p2'}) 实现方式该方法要比all简单 1234567891011121314function PromiseRace(arr) { return new Promise((resolve, reject) =&gt; { arr.forEach((p, index) =&gt; { // 使用 Promise.resolve()将不是Promise对象转换为Promise对象 // 调用每一个promise对象的then方法 // 之后直接resolve或reject Promise.resolve(p).then(result =&gt; { resolve(result) }, (err) =&gt; { reject(err) }) }) })} 总结以上就是Promise.all和Promise.race的介绍以及源码实现。 还是比较简单，不过有个注意的点就是使用Promise.resolve(p)将非Promise对象转为Promise对象，这样才能调用then方法","link":"/blog/articles/2019-07-30-promise-all-race.html"},{"title":"清除浮动解决方案，使用.clearfix类选择器","text":"这个东西其实很简单 使用css 12345.clearfix::after { display: block; content: \"\"; clear: both;} 直接把要清除浮动的添加clearfix就行了 演示html 123&lt;div class=\"container\"&gt; &lt;div class=\"floated\"&gt;floated&lt;/div&gt;&lt;/div&gt; css 123456789101112131415161718.clearfix::after { display: block; content: ''; clear: both;}div { border: 1px dashed skyblue;}.container { width: 200px; background: rgb(83, 152, 197);}.floated { height: 300px; float: left; background: rgb(224, 173, 107);} 容器未被撑开 添加clearfix 123&lt;div class=\"container clearfix\"&gt; &lt;div class=\"floated\"&gt;floated&lt;/div&gt;&lt;/div&gt; 容器被撑开，浮动清除 clearfix还可以加入flow-root属性 123456789101112131415.clearfix::after { display: block; content: \"\"; clear: both;}/* 如果浏览器支持 flow-root属性 */@supports(display: flow-root) { .clearfix::after { display: none; } .clearfix { display: flow-root } } 关于flow-root，我的这篇文章有讲解","link":"/blog/articles/2019-07-30-clearfix.html"},{"title":"HTML的history API","text":"HTML 5提供了一个新的API：history，它能够操纵浏览器的历史记录信息 下面就对其进行简单的介绍 浏览历史 前进、后退 1window.history.forward() 1window.histroy.back() 到特定历史 后退一个页面 1window.history.go(-1) 前进一个页面 1window.history.go(1) 前进或后退n个页面 12window.history.go(n)window.history.go(-n) 使用go(0)或者go()刷新页面 12window.history.go(0)window.history.go() // 两个都相同 获取历史记录长度 1window.history.length 对历史记录操作HTML 5 添加了history.pushState()和history.replaceState()方法可以对历史记录条目进行添加或修改。 假设你在http://its-silver.com/blog执行了下面代码 1234let stateObj = { foo: 'bar'}history.pushState(stateObj, 'archive', 'archive') 页面地址就会显示http://its-silver.com/blog/archive 但是页面地址并不会发生跳转，vue-router的mode: history就是靠这个来实现的 pushState() 方法参数 state object 使用history.state可以访问到当前记录的state，用于存储 title 似乎目前没啥作用 URL 浏览器显示的新地址，可以使用相对路径或绝对路径。如果发生跨域会产生报错 replaceState() 方法history.replaceState()与history.pushState()行为相同，唯一的区别就是： history.replaceState()替换了当前历史记录 history.pushState()添加了一条新纪录 popstate 事件触发事件 点击前进或后退按钮 使用history.go() history.forward() history.back() 使用pushState()或者replaceState()并不会触发该事件 事件的 state 属性是当前历史记录 history.state 的拷贝 12345678910window.onpopstate = function(event) { alert(\"location: \" + document.location + \", state: \" + JSON.stringify(event.state));};history.pushState({page: 1}, \"title 1\", \"?page=1\");history.pushState({page: 2}, \"title 2\", \"?page=2\");history.replaceState({page: 3}, \"title 3\", \"?page=3\");history.back(); // alerts \"location: http://example.com/example.html?page=1, state: {\"page\":1}\"history.back(); // alerts \"location: http://example.com/example.html, state: nullhistory.go(2); // alerts \"location: http://example.com/example.html?page=3, state: {\"page\":3} 读取State使用history.state读取当前记录的state 1let currentState = history.state","link":"/blog/articles/2019-08-20-HistoryAPI.html"},{"title":"使用display: table\\table-cell属性让容器水平或垂直居中","text":"居中页面元素有很多种方式 利用flex、grid、绝对定位+负边距或者transform、text-align等等方式，他们适用于不同的场景，比如text-align就只能对inline元素起作用，vertical-align在默认情况下只是对行框内容进行对齐 下面介绍两种块级元素的居中方式 display: table\\table-cell 最近做页面的时候突然想起来用这个属性配合margin-auto同样可以实现居中 display: table实现水平居中 1234div { display: block table; margin: auto;} 原理 display: block table和display: table一样的 display: table属性能够使得容器自适应宽度，而不是像block元素那样占满一行，所以能够使用block固定宽度元素的居中方式，使用margin: auto进行居中 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;使用display: table进行居中&lt;/title&gt; &lt;style&gt; div { border: 1px solid orange; display: table; margin: auto; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;I'm centered&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; display: table-cell实现垂直居中 1234div { display: table-cell; vertical-align: middle;} 原理 table-cell属性的元素可以使用vertical-align将内部元素居中于容器 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt; div.outer { display: table-cell; vertical-align: middle; width: 500px; height: 200px; border: 1px solid orange; } div.inner { background: black; color: white; padding: 20px; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt;I'm centered&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这两个属性在某些情况下还是挺实用的，分享给大家。","link":"/blog/articles/2019-08-05-table-center.html"},{"title":"使用Javascript实现对象浅拷贝和深拷贝","text":"对象的浅拷贝与深拷贝javascript原生里并没有对对象拷贝的函数，要实现对象的拷贝，可以使用以下方法。 浅拷贝只拷贝对象的值，即将该对象的属性复制给另一个对象，如果对象里面包含另一个对象，只是将引用复制了而已。所以浅拷贝也可以理解为只拷贝一层。 要实现浅拷贝，可以通过遍历将属性赋值给另一个对象，也可以直接使用Object.assign()方法使用Object.assign() 1234567891011121314let Oa = { a: 1, b: 2, Oc: { d: 3, e: 4 }}let Ob = Object.assign({}, Oa)console.log(Ob)// { a: 1, b: 2, Oc: { d: 3, e: 4 } }console.log(Ob.Oc === Oa.Oc)// true 这里Ob的属性Ob.Oc === Oa.Oc即两个对象是相等的，复制的引用 深拷贝 拷贝对象的属性，如果对象属性有另一个对象，将这个对象也拷贝，而不是直接使用引用。所以深拷贝可以理解为拷贝多层。 使用递归方法 1234567891011121314151617181920212223242526272829303132333435let Oa = { a: 1, b: 2, Oc: { d: 3, e: 4 }, Od: [1, 2, 3, 4]}function deepClone(src) { // 判断src是否为数组，以便返回对象或数组 let target = Array.isArray(src) ? [] : {}; for (let prop in src) { // 过滤掉原型链上的属性， 只遍历自身属性 if (src.hasOwnProperty(prop)) { // 如果值为一个对象或数组，则复制该对象或数组的所有属性 if (typeof src[prop] === 'object') { target[prop] = deepClone(src[prop]) } // 如果是原始数据类型 else { target[prop] = src[prop] } } } return target}let Ob = deepClone(Oa)console.log(Ob) // { a: 1, b: 2, Oc: { d: 3, e: 4 }, Od: [ 1, 2, 3, 4 ] }console.log(Ob.Oc === Oa.Oc)// falseconsole.log(Ob.Od === Oa.Od)// false 这里Ob的属性Ob.Oc === Oa.Oc即两个对象不相同，实现了深拷贝 转换为JSON字符串再转换回对象 - 使用JSON.stringify()和JSON.parse() 1234567891011121314151617181920function cloneWithJSON(src) { return JSON.parse(JSON.stringify(src))}let Oa = { a: 1, b: 2, Oc: { d: 3, e: 4 }}let Ob = cloneWithJSON(Oa)console.log(Ob) // { a: 1, b: 2, Oc: { d: 3, e: 4 }, Od: [ 1, 2, 3, 4 ] }console.log(Ob.Oc === Oa.Oc)// falseconsole.log(Ob.Od === Oa.Od)// false 深拷贝的循环引用问题上面的深拷贝函数中，没有考虑到循环引用的问题，如果出现了循环引用将造成死递归，最终爆栈。 123456789101112let Oa = { a: 1, b: 2, Oc: { d: 3, e: 4 }, Od: [1, 2, 3, 4],}Oa.Of = Oalet Ob = deepClone(Oa)// RangeError: Maximum call stack size exceeded 因此，为此做出优化，使用以下方法。 设置一个map，visited，标记访问过的对象，并存储对应的的拷贝对象的引用，如果对象被访问过，则不进行递归调用，直接将值指向该引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556let Oa = { a: 1, b: 2, Oc: { d: 3, e: 4 }, Od: [1, 2, 3, 4],}Oa.Of = Oafunction deepClone(src) { // 存储访问过的节点 let visited = new Map() return deepClonehelper(src, visited)}function deepClonehelper(src, visited) { // 判断src是否为数组，以便返回对象或数组 let target = Array.isArray(src) ? [] : {}; // 置为访问过，并将对应的target对象的引用保存 visited.set(src, target) for (let prop in src) { // 过滤掉原型链上的属性， 只遍历自身属性 if (src.hasOwnProperty(prop)) { // 如果值为一个对象或数组，则复制该对象或数组的所有属性 if (typeof src[prop] === 'object') { // 如果未访问过 if (!visited.has(src[prop])) { target[prop] = deepClonehelper(src[prop], visited) } else { // 访问过，将该属性指向这个拷贝后的节点 target[prop] = visited.get(src[prop]) } } // 如果是原始数据类型 else { target[prop] = src[prop] } } } return target}let Ob = deepClone(Oa)console.log(Ob) // { a: 1, b: 2, Oc: { d: 3, e: 4 }, Od: [ 1, 2, 3, 4 ], Of: [Circular] }console.log(Ob.Of === Oa.Of)// falseconsole.log(Ob.Of === Ob)// true 以上就是对象拷贝的简单实现","link":"/blog/articles/2019-09-22-对象拷贝.html"},{"title":"数组扁平化","text":"数组扁平化数组扁平化是讲一个多维数组编程一个一维数组 12[1, 2, 3, [4, 5, [6, 7]]] // 转换前[1, 2, 3, 4, 5, 6, 7] // 转换后 下面介绍几种数组扁平化的方式 1. 简单递归实现这里将flat函数挂载到原型链上 12345678910111213141516171819Array.prototype.flat = function() { let arr = this // 数组本身 let ret = [] // 存储扁平化后的数组 arr.forEach((item) =&gt; { // 判断是否为数组 if (!Array.isArray(item)) { // 如果不为数组，将该项直接push到ret ret.push(item) } else { // 如果为数组，则调用其flat()方法，使用es6的扩展运算符将结果push到ret ret.push(...item.flat()) } }) return ret}let arr = [1, 2, 3, [4, 5, [6, 7]]]console.log(arr.flat()) // [1, 2, 3, 4, 5, 6, 7] 2. ES6 flat方法使用es6的arr.flat()方法即可，传入的参数为扁平化的层数，如果为Infinity则表示不管多少层，都扁平化为一维数组 12345let arr = [1, 2, 3, [4, 5, [6, 7]]]console.log(arr.flat(Infinity)) // [1, 2, 3, 4, 5, 6, 7]console.log(arr.flat(1))// [1, 2, 3, 4, 5, [6, 7]] 3. 模拟es6方法上面的第一种方式已经实现了数组扁平化，现在要传入一个参数level，表示扁平化的层数。 并且在开始判断层数是否存在，或者是否小于等于0 递归的时候传入参数 level - 1 即可 1234567891011121314151617181920212223242526Array.prototype.flat = function(level) { // 判断level是否存在，或小于等于0 if (!level || level &lt;= 0 ) { return this } let arr = this // 数组本身 let ret = [] // 存储扁平化后的数组 arr.forEach((item) =&gt; { // 判断是否为数组 if (!Array.isArray(item)) { // 如果不为数组，将该项直接push到ret ret.push(item) } else { // 如果为数组，则调用其flat()方法，使用es6的扩展运算符将结果push到ret // 参数为 level - 1 ret.push(...item.flat(level - 1)) } }) return ret}let arr = [1, 2, 3, [4, 5, [6, 7, [8, 9]]]]console.log(arr.flat(0)) // [ 1, 2, 3, [ 4, 5, [ 6, 7, [Array] ] ] ]console.log(arr.flat(1)) // [ 1, 2, 3, 4, 5, [ 6, 7, [ 8, 9 ] ] ]console.log(arr.flat(2)) // [ 1, 2, 3, 4, 5, 6, 7, [ 8, 9 ] ]console.log(arr.flat(Infinity)) // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] 以上就是数组扁平化的简单实现，核心思想就是递归","link":"/blog/articles/2019-09-22-数组扁平化.html"},{"title":"简介http缓存机制","text":"通过网络提取内容既速度缓慢又开销巨大。 较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。 因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面 昨天正好面试到了，所以也是对自己知识的一个补充吧，下面就对http缓存进行介绍。 所谓缓存，可以理解为中间的存储。在请求资源的时候，不通过网络，而是直接使用磁盘或者内存中已经在上一次请求中所下载到的资源，这样就避免了网络传输的延迟，优化了页面加载速度。 在了解Http的缓存机制之前，先来看看http中有哪些缓存 http缓存中有两种缓存 强制缓存 协商缓存 ## 强制缓存 客户端直接通过缓存中获取数据，不会于服务端发生交互 对于强制缓存，服务器响应中有两个字段 Expires Cache-Control Expires 它是http/1.0中的缓存机制，它描述的是一个绝对的时间。当第一次请求资源时，响应体会包含Expires字段。 1Expires: Tue, 22 Oct 2019 07:58:14 GMT 如果当前请求的时间大于Expires字段的时间，那么说明强制缓存已经过期。 Expires 字段的这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当客户端本地时间被修改以后（修改系统的时间），就有可能导致缓存混乱。于是发展出了Cache-Control Cache-Control 指令不区分大小写，并且具有可选参数，可以用令牌或者带引号的字符串语法。多个指令以逗号分隔。 常见取值public、private、no-cache、max-age、no-store，默认为private private：响应只能被单个用户缓存，不能作为共享缓存（代理服务器不能缓存） public：可以被任何对象缓存（包含发送请求的客户端，代理服务器 ) no-cache：这里的no-cache不是表示不使用缓存，表示先把缓存提交给服务器验证（ 后面的协商缓存） no-store： 表示不适用缓存，直接发送请求 max-age：设置缓存的生存周期，（单位秒） 比如，当Cache-Control中指定了max-age=600 12Date: Tue, 22 Oct 2019 09:27:42 GMTCache-Control: max-age=600 表示该缓存在10分钟后过期，配合响应中的Date，就能得出缓存过期的时间 协商缓存（有的也称对比缓存）当强制缓存过期后，使用协商缓存，这时会发送一些字段给服务器验证，查看缓存是否过期 如果没有过期则返回状态码304，之后直接使用缓存作为响应体。 如果已经过期，则重新通过网络传输文件 协商缓存一般有下面的两种 Last-Modified/If-Modified-Since Etag/If-None-Match Last-Modified/If-Modified-Since 服务器响应请求时，头部会加上Last-Modified，表示该资源的最后修改时间 1Last-Modified: Fri, 18 Oct 2019 05:43:24 GMT 之后的客户端发起的每次请求都在If-Modified-Since设置为该值 1If-Modified-Since: Fri, 18 Oct 2019 05:43:24 GMT 这样服务端通过对比If-Modified-Since和资源最后的修改时间判断是否命中缓存 Last-Modified虽然已经足够好，但是Last-Modified只能精确到秒，如果某些文件在1秒内被修改多次，它将不能准确标注文件被修改的具体时间。 有些相同的文件会定时生成，他们的Last-Modified不同，导致没法使用缓存 所以又有了下面的Etag Etag/If-None-Match 与上面不同的是，该方法通过一个标识符来确定是否命中缓存 服务器响应请求时，头部会加上Etag(Entity Tag)，它是该资源的唯一标识，Etag的值改变了说明资源已经更新 1Etag: W/&quot;5da950fc-3be&quot; 客户端发送请求时，在If-None-Match字段加上Etag的值 1If-None-Match: W/&quot;5da950fc-3be&quot; 服务端将收到的If-None-Match字段与Etag对比，如果相同则命中缓存 http缓存机制通常情况下，http缓存会以如下方式工作 浏览器第一次请求 第一次请求时，发现无缓存，则直接向web服务器请求，web服务器返回响应，并缓存。如果设置了Cache-Control: no-store之类的则不会缓存文件。 再次请求 再次请求时： 查看缓存的中响应的Cache-Control或Expires字段，如果两者同时存在，则查看Cache-Control 若资源过期，比如Cache-Control的max-age=10，你在10秒后发送了这个请求，此时资源已经过期，则检查是否带有Etag 若带有Etag，将这个Etag的值作为请求If-None-Match字段的值，发送给服务器验证，返回304或者200 若没有Etag，检查是否有Last-Modified 若有Last-Modified，将这个Last-Modified的值作为请求If-Modified-Since的值，发给服务器验证，返回304或者200 若没有Last-Modified，则直接向web服务器请求资源","link":"/blog/articles/2019-10-22-http-cache.html"},{"title":"CSS动画-auto属性的过渡","text":"通常，你想要通过css transition来过渡属性，然后使用了下面代码transition: height 0.5s linear 然后又使用了 height: auto来自适应高度height: 0 -&gt; height: auto 然后发现动画就像没发生一样，直接就在0和auto两个状态之间直接切换 你可能会认为出现了什么bug，或者代码写错了，其实不然 你可能发生下图所示的情况 在这篇文章中，都使用高度进行说明，这张图里的宽度与高度是一个道理 这个问题目前还不能简单通过css完全解决 下面是我分享的4个解决方案 本文章部分资料以及Code Pen代码引用于 css-tricks.com， 里面有很多关于css的技巧，值得学习 这是浏览器bug?查阅Mozilla Developer Network docs， auto 属性值被排除在transition规范之外。 这样做的原因是因为，如果transition一个元素的高度到auto，浏览器将会进行页面重排(reflow)，重排页面会计算其他元素的位置，并且在每一个动画帧都会进行这样的操作，这意味着将花费巨大的开销。 虽然设置height: auto达到不了我们想要的效果，但是可以通过其他方法实现，下面介绍4种方式 使用max-height 使用transform: scaleY() 使用Javascript 使用Flex容器 解决方案 1: 使用 max-height这个方法可能是最容易搜索到的方法，但是不太理想，不过在一些情况下，还是值得使用 具体方法大概如下： ​ 设置 transition: max-height 0.3s ease-out ​ max-height: 0 ​ 过渡到一个该容器能达到的最大值，比如 1000px ​ max-height: 1000px 这里的max-height必须保证大于容器auto的height，不然就会出现内容显示不全的情况 Code Pen演示 在以下的code pen演示中都使用的SCSS，如果需查看CSS，请点击下面的View Compiled按钮 主要注意.section这部分 123456789.section { overflow:hidden; transition:max-height 0.3s ease-out; /* 设置max-height的transition属性 */ height:auto; max-height:600px; /* 这里仍然需要硬编码 */}.section.collapsed { max-height:0;} See the Pen Smooth Collapsing div with max-height by Chen Yinyi (@CYSILVER) on CodePen. 缺点可能你也发现了，这里的max-height也是硬编码，大多数情况下也不好确定容器的最大内容高度。 其次，设置的transition的时间和变换函数和实际展示出来的并不一致 打个比方 ​ 内容的实际最高宽度为100px ​ 你设置了: ​ max-height: 0 -&gt; max-height: 1000px ​ transition: max-height 10s linear; ​ 那么这里的10s的transition显示在浏览器上就只有1s，因为1s后max-height: 100px已经达到容器最大高度，后面的max-height的变化不会体现出来 ​ 解决方案 2: transform: scaleY()该方法不会触发页面重排(reflow) 设置方法很简单 设置 transform: scaleY(0) 到 transform: scaleY(1) 即可完成高度的缩放 该方法不会触发重排，所以元素位置不会改变，同时元素的内容会产生挤压的形变效果 Code Pen 演示12345678910.section { overflow:hidden; transition:transform 0.3s ease-out; /* 设置transform的transition属性 */ height:auto; transform:scaleY(1); /* 可以不用显示声明，但最好的做法是在这里声明一下 */ transform-origin:top; /* 设置transform的起始点，不然就会从中间开始缩放 */}.section.collapsed { transform:scaleY(0); /* 设置为0 */} See the Pen Smooth Collapsing div with scaleY() by Chen Yinyi (@CYSILVER) on CodePen. 缺点该方法普遍不适用 产生的形变效果大部分时候不是我们想要的，也不够没关 不会产生页面重排，折叠后的位置留空，大部分时候不是我们想要的情况 解决方案 3: Javascript（推荐）该方法使用js获取到内容的最大高度，然后就能使用固定的高度进行transition了 基本思路是使用，获取到元素的高度 1element.scrollHeight 然后设置 1element.style.height = scrollHeight 点击后设置 1element.style.height = 0 这样就能实现css的transition效果，并且移除了硬编码，更加灵活，适用于任意高度的容器 Code Pen 演示要点在这两部分 12var sectionHeight = element.scrollHeight; // 获取到内容的高度element.style.height = sectionHeight + 'px'; // 设置Height 关于scrollHeight Element.scrollHeight 这个只读属性是一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容。 我这里放个图大家就知道了 See the Pen Smooth Collapsing div with Javascript by Chen Yinyi (@CYSILVER) on CodePen. 这里使用到了requestAnimationFrame()，关于这个我会在之后的博文讲解。 下面是我写的另外一种做法，比这个要直观一点 12345678910111213141516171819document.querySelectorAll('.dropdown-nav__title').forEach((item, index) =&gt; { item.addEventListener( 'click', (function(event) { // 利用闭包存储状态 let opened = false return function(event) { let scrollHeight = event.target.nextElementSibling.scrollHeight requestAnimationFrame(() =&gt; { // 切换height event.target.nextElementSibling.style.height = opened ? '0' : `${scrollHeight}px` opened = !opened }) } })() //立即执行函数，返回内部的function ) }) See the Pen dropDown-menu by Chen Yinyi (@CYSILVER) on CodePen. 缺点同样的，这里没有避免掉页面重排的问题 不过在某些特定的情况下，可以通过使用绝对定位来避免页面重排，比如导航栏的下拉菜单如果需要设置动画，就不需要重排页面。 解决方案 4: FlexBox (额外方式)之所以称之为额外方式，是因为从技术上来说该方式没有达到预期的效果，不过却是另外一种不错的方法 如果你还不够了解flexbox 和 flex-grow两个属性，推荐阅读 阮一峰的Flex 布局教程 A Complete Guide to FlexBox (英文) 这里的话主要就是用到的flex这个属性了(实质上为flex-grow) Code Pen 演示123456789.section { overflow:hidden; /* 注意这里是关键 */ transition:flex 0.3s ease-out; /* 设置flex的transition */ height:auto; flex:1; /* 设置flex为1，或者1以上，即容器能够自动伸长，关于这个值的作用请见flexbox的教程 */}.section.collapsed { flex: 0; /* 设置flex为0，即容器不会自动伸长 */} 请注意上面的 1overflow: hidden; 这句话是关键，可替换为 1min-height: 0; 因为默认情况下，元素不会缩短至小于内容框尺寸，若想改变这一状况，请设置元素的min-width与 min-height属性。同样的设置overflow: hidden也可达到相同效果 See the Pen Smooth Collapsing div with Flexbox by Chen Yinyi (@CYSILVER) on CodePen. 这又是另一种效果，所以说是一种额外的解决方法。 不过这种方法利用了flexbox，更加灵活 总结这四种方式各有优缺点，没有优劣，不过个人还是比较喜欢用js的方式，不过至于到底该用哪个，根据你的需求和情况而定。","link":"/blog/articles/2019-07-29-CSS动画-auto属性的过渡.html"},{"title":"了解css中的block formatting context(块级上下文) 以及 display: flow-root","text":"块级上下文挺起来很抽象，W3C 中是这样解释的： floats, absolute定位, 不是块级元素的块级容器(列如inline-block, table-cells, table-captions)，以及display为overflow等不是visible属性的元素，会为它们包含的内容建立新的block formatting context 在block formatting context中，以容器的顶端为开始，Box一个接一个的垂直排列，两个相邻box之间的距离由margin决定，在相同的block formatting context中，两个相邻的块级Box会产生外边距合并 (这是重点) 在block formatting context中，每一个Box的左边界紧挨着容器左边界(如果是从右到左的布局，那么触碰到右边界)。 在floats元素依然满足此要求(但是Box内的行框由于float可能会变窄)，除非建立了新的block formatting context(这种情况下box会由于float元素而变窄) 上面的话可以总结为： block formatting context就是页面上的一个隔离的独立容器，容器内的子元素不会影响到外面的元素。反之如此 看了这么多，是不是感觉很抽象，没关系，我们与其去研究这些抽象的文字，不如来看看block formatting context能做什么。 了解BFC(Block Formatting Context)块级上下文BFC的创建通过上面的介绍可以知道，设置display、position、float、overflow均可以为元素创建BFC 这里设置overflow: hidden，这样就创建了bfc 123&lt;div class=\"container\"&gt; Some Content here&lt;/div&gt; 123.container { overflow: hidden;} 外边距合并同一个BFC里面的相邻元素会产生外边距合并 如下，设置的p的上下外边距为10px，合并后仍为10px 1234&lt;div class=\"container\"&gt; &lt;p&gt;Sibling 1&lt;/p&gt; &lt;p&gt;Sibling 2&lt;/p&gt;&lt;/div&gt; 123456789.container { background: orange; overflow: hidden;}p { background: skyblue; margin: 10px 0;} 了解了BFC能做些什么？下面介绍使用bfc 阻止外边距合并 清除浮动 防止文字环绕 下面一起来看看吧 阻止外边距合并让两个元素不在同一个BFC中就可以阻止外边距合并 下面将Sibling 3的容器设置为新的BFC，第三个p和第二个p的外边距就不会合并 1234567&lt;div class=\"container\"&gt; &lt;p&gt;Sibling 1&lt;/p&gt; &lt;p&gt;Sibling 2&lt;/p&gt; &lt;div class=\"newBFC\"&gt; &lt;p&gt;Sibling 3&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112 .container { background: orange; overflow: hidden;}p { background: skyblue; margin: 10px 0;}.newBFC { overflow: hidden;} Demo See the Pen prevent margin collapse by Chen Yinyi (@CYSILVER) on CodePen. ## 清除浮动 设置BFC能够清除浮动 BFC中的子元素不会影响外部元素，所以在BFC中，容器能够撑开包含浮动元素，所以设置bfc能够实现清除浮动 1234&lt;div class=\"container\"&gt; &lt;div&gt;Sibling 1&lt;/div&gt; &lt;div&gt;Sibling 2&lt;/div&gt;&lt;/div&gt; 12345678910.container { background: orange; overflow: hidden;}div { float: left; background: skyblue; margin: 10px;} Demo See the Pen bfc clear float by Chen Yinyi (@CYSILVER) on CodePen. 防止文字环绕首先我们再回顾下上面的BFC描述: 在block formatting context中，每一个Box的左边界紧挨着容器左边界(如果是从右到左的布局，那么触碰到右边界)。 在floats元素依然满足此要求(但是Box内的行框由于float可能会变窄)，除非建立了新的block formatting context(这种情况下box会由于float元素而变窄) 也就是说在默认情况下，float元素盖在p上面后，文字的行框会由于float变窄，所以就会产生文字环绕的现象。由于bfc的特性：内部布局不会影响到外部，反之如此，通过给段落&lt;p&gt;建立bfc，就能实现阻止文字环绕的效果 下面的代码给p元素设置了overflow: hidden，创建了bfc，最终实现防止文字环绕 1234&lt;div class=\"container\"&gt; &lt;div class=\"floated\"&gt;I'm floated&lt;/div&gt; &lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Hic modi laudantium unde qui tenetur labore. Dolor quaerat soluta nobis facere, obcaecati temporibus consectetur illo atque. Non excepturi voluptates ducimus odit?&lt;/p&gt;&lt;/div&gt; 123456789101112131415.container { background: orange; width: 200px;}div { float: left; background: skyblue; margin: 10px;}p { border: 1px solid green; overflow: hidden;} Demo See the Pen bfc clear text wrap by Chen Yinyi (@CYSILVER) on CodePen. 设置display: flow-root设置元素属性display: flow-root可以为元素创建新的bfc 它不像overflow: hidden那样会将溢出内容隐藏 也不会像overflow: scroll那样会产生滚动条 它就是单纯的创建bfc 通过这样的理解，你就能明白这个属性能干什么了，上面所讲的列子，都能通过设置display: flow-root 阻止外边距合并 清除浮动 防止文字环绕 对于[浏览器支持情况 ]([https://caniuse.com/#search=display%3A%20flow-root](https://caniuse.com/#search=display%3A flow-root)) 现阶段有部分浏览器不支持此属性 列如上图中的IE、Opera Mini、 IOS Safari等 总结​ 对于BFC的定义及使用就介绍到这里了，当初看那些bfc的文章介绍的时候，都是统统给你搬出来一堆概念，咬文嚼字看完几遍后依旧看不懂。最后我改变了学习方向，与其去深究定义，不如去看看它能够做什么。你问我bfc的严格定义，我可能也不能好好的回答上来，不过掌握了这些方法，相信你会对bfc有了新的理解。 ​ 我想说的是，学习不要卡在一个死胡同，定义看不懂，就多去实践，看看有什么效果，再返回去理解定义的内容，这样也许会帮助你更快的理解，同时留下的印象也就更深。","link":"/blog/articles/2019-07-31-bfc.html"}],"tags":[{"name":"javascript","slug":"javascript","link":"/blog/tags/javascript/"},{"name":"dom","slug":"dom","link":"/blog/tags/dom/"},{"name":"bug","slug":"bug","link":"/blog/tags/bug/"},{"name":"vim","slug":"vim","link":"/blog/tags/vim/"},{"name":"vscode","slug":"vscode","link":"/blog/tags/vscode/"},{"name":"html","slug":"html","link":"/blog/tags/html/"},{"name":"css","slug":"css","link":"/blog/tags/css/"},{"name":"gulp","slug":"gulp","link":"/blog/tags/gulp/"},{"name":"博客优化","slug":"博客优化","link":"/blog/tags/博客优化/"},{"name":"webpack","slug":"webpack","link":"/blog/tags/webpack/"},{"name":"js","slug":"js","link":"/blog/tags/js/"},{"name":"es6","slug":"es6","link":"/blog/tags/es6/"},{"name":"html5","slug":"html5","link":"/blog/tags/html5/"},{"name":"web","slug":"web","link":"/blog/tags/web/"},{"name":"http","slug":"http","link":"/blog/tags/http/"},{"name":"cache","slug":"cache","link":"/blog/tags/cache/"},{"name":"animation","slug":"animation","link":"/blog/tags/animation/"},{"name":"css动画","slug":"css动画","link":"/blog/tags/css动画/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/blog/categories/javascript/"},{"name":"github","slug":"github","link":"/blog/categories/github/"},{"name":"gulp","slug":"gulp","link":"/blog/categories/gulp/"},{"name":"webpack系列教程","slug":"webpack系列教程","link":"/blog/categories/webpack系列教程/"},{"name":"dom","slug":"javascript/dom","link":"/blog/categories/javascript/dom/"},{"name":"布局","slug":"布局","link":"/blog/categories/布局/"},{"name":"es6","slug":"javascript/es6","link":"/blog/categories/javascript/es6/"},{"name":"css","slug":"css","link":"/blog/categories/css/"},{"name":"javasccript","slug":"javasccript","link":"/blog/categories/javasccript/"},{"name":"web","slug":"web","link":"/blog/categories/web/"}]}