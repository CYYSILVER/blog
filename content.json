{"pages":[{"title":"about","text":"","link":"/blog/about/index.html"},{"title":"categories","text":"","link":"/blog/categories/index.html"},{"title":"tags","text":"","link":"/blog/tags/index.html"}],"posts":[{"title":"VscodeVim 遇到的奇葩bug","text":"bug已经提交至githubhttps://github.com/VSCodeVim/Vim/issues/3864当使用插件VscodeVim和auto rename tag，新建文件在第一行输入： 1&lt;% if(get_config(&apos;toc&apos;) === true &amp;&amp; (post.layout === &apos;page&apos; || post.layout === &apos;post&apos; )) { 输入到第三个 ‘===’ 的时候编辑器就会开始卡，输入一个字符很卡，但是能正常进行其他操作太奇葩了关掉其中任意一个插件都能够正常运行 Bub 描述 操作系统: Windows 10 1903 Vscode 插件: VscodeVim, Auto Rename Tag Vscode 版本: 1.36.0 问题: 在文件中输入以下的代码会卡住键盘不能输入，但是仍然能够使用方向键移动光标 1&lt;% if(get_config(&apos;toc&apos;) === true &amp;&amp; (post.layout === &apos;page&apos; || post.layout === &apos;post&apos; )) { 在输入第三个 “===” 会产生卡顿 卡顿后仍然能够移动光标 只有在安装过vim和auto rename tag 插件后才会有冲突 Actually I’m really confused how it would work, Are my PC broken… 说实话我真不知道这玩意的原理是什么，开始我怀疑我系统问题，后来找了几个朋友测试都这样。真实个奇葩的问题 重现bugSteps to reproduce the behavior:步骤 打开Vscodej 按Ctrl+Shift+P 打开command line 输入ext: disable all 选择 Extensions: Disable All Installed Extensions 点击左侧插件 安装 vim 和 auto rename tag 插件 (两个都得启用) 创建新文件命名为 “test” (命名随便) 打开文件, 按i进入vim插入模式 输入以下的代码 *(! 注意不能忽视空格 ) *&lt;% if(get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post' )) { Expected behavior当输入到第三个 “===” 的时候就会开始卡顿 会明显感受到输入延迟, 有种打不动字的感觉 当完成输入后, 按backspace退格也会产生相同的感觉 卡顿时可能无法输入任何文字, 但能够使用方向键移动 Screenshots 运行环境 Running Extensions Node Debug Auto-attach Emmet Git Merge Conflict Auto Rename Tag 0.1.0 Vim Extension (VsCodeVim) version: 1.8.1 VSCode version: 1.36.0 OS: Windows 10 1903 提交原文Describe the bug System: Windows 10 1903 Vscode Plugins: VscodeVim, Auto Rename Tag Vscode Version: 1.36.0 bug: type the following code in a line will likely freeze your keyboard but you still can move caret with arrow key. 1&lt;% if(get_config(&apos;toc&apos;) === true &amp;&amp; (post.layout === &apos;page&apos; || post.layout === &apos;post&apos; )) { You will get stuttering when you type to the third “===” You can still move your caret when you get stuttering You can only produce the behavior when you installed both vim and auto rename tag extensions Actually I’m really confused how it would work, Are my PC broken… To ReproduceSteps to reproduce the behavior: Open Vscode Press Ctrl+Shift+P open command line Type ext: disable all Select Extensions: Disable All Installed Extensions Go to Extensions Install vim and auto rename tag (both should be enabled) Create a new file named “test” In the file, press i enter the vim insert mode Type the following code (! Can not ignore spaces)&lt;% if(get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post' )) { Expected behaviorWhen reach the third “===” stuttering would occur you can continue type but it feel lag and stutter when you finished and press backspace produce the same behavior you may can’t type any word but you can still move your caret with arrow key Screenshots Environment Running Extensions Node Debug Auto-attach Emmet Git Merge Conflict Auto Rename Tag 0.1.0 Vim Extension (VsCodeVim) version: 1.8.1 VSCode version: 1.36.0 OS: Windows 10 1903","link":"/blog/articles/2019-07-05-VscodeVim-bug.html"},{"title":"使用原生JS实现wrap与unwrap","text":"jquery中提供了.wrap()与.unwrap()方法下面介绍一下原生js的实现方法 使用原生JS实现wrap 创建包裹的元素 在被包裹的节点前插入元素 将该节点移入包裹节点 js代码如下 12345678var wrapper = document.createElement('div')var el = document.querySelector('.wrap-me')// 在该节点前插入wrapperel.parentElement.insertBefore(wrapper, inner)// 将该节点移入wrapperwrapper.appendChild(el) HTML代码 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"outer\"&gt; &lt;div class=\"wrap-me\"&gt;this is inner text&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;var wrapper = document.createElement('div')var el = document.querySelector('.wrap-me')// 在该节点前插入wrapperel.parentElement.insertBefore(wrapper, inner)// 将该节点移入wrapperwrapper.appendChild(el)&lt;/script&gt; 使用原生JS实现unwrap 将所有元素移出该元素 删除该元素 JS代码如下 123456789101112var wrapper = document.querySelector('.wrapper li')function unwrap(ele) { /* 父元素引用 */ const parent = ele.parentElement /* 如果存在子元素，将其移出 */ while(ele.firstChild) { parent.insertBefore(ele.firstChild, ele) } /* 删除该元素 */ parent.removeChild(ele)}unwrap(wrapper) HTML代码如下 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=5, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;ul class=\"wrapper\"&gt; &lt;li class=\"wrapper\"&gt; &lt;p&gt;I' m inside element&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;I' m outside element&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;var wrapper = document.querySelector('.wrapper li')function unwrap(ele) { const parent = ele.parentElement while(ele.firstChild) { parent.insertBefore(ele.firstChild, ele) }}unwrap(wrapper)&lt;/script&gt;","link":"/blog/articles/2019-07-02-使用原生JS实现wrap与unwrap.html"},{"title":"webpack入门(1): 核心概念","text":"介绍webpack 是一个用于编译Javascript模块的工具，在安装webpack之后，可以通过 CLI (command line interface 就是在控制台上使用 ) API (在js中导入模块使用) 在使用webpack之前，如果你还是一个新手，请阅读下面的核心概念之后，再进行操作 如果你想直接进入操作来学习，请进入 webpack入门之安装与使用 核心概念webpack 本质上就是个 静态模块打包器(module bundler)。webpack处理程序时会创建依赖关系图，把你应用程序中用到的文件打包成一个或者多个文件 *这里可以了解更多关于 JavaScript 模块和 webpack 模块的信息* 从4.0.0版本之后，使用webpack不需要再创建一个配置文件 以下介绍几个核心概念 Entry (入口) Output (出口) Loaders Plugins (插件) Mode Browser Compatibility (浏览器兼容性) Entry 入口入口表示你的webpack打包开始的文件，它会寻找该文件依赖的其他文件，将他们合并打包。 可以通过webpack config中的entry属性，来定义一个（或者多个起点） 默认值为./src/index.js webpack.config.js 123module.exports = { entry: './path/to/my/entry/file.js'}; Output 出口即打包后完成文件输出的目录 默认输出js为./dist/main.js 其他文件在./dist webpack.config.js 1234567891011const path = require('path');module.exports = { entry: './path/to/my/entry/file.js', output: { /* 指定输出目录 */ path: path.resolve(__dirname, 'dist'), /* 指定输出文件名 */ filename: 'my-first-webpack.bundle.js' }}; 使用output.filename和output.path来指定文件名和路径 顶部引入的const path = require('path')是Node.js用于操作文件路径的模块 Loaderswebpack本身只能处理Javascript，使用loader可以让webpack让其他类型文件转换为webpack能够处理的模块 loader 能够import 导入任何类型的模块（例如.css 文件），这是 webpack 特有的功能 loader在webpack中配置如下 webpack.config.js 12345678910111213141516const path = require('path');const config = { output: { filename: 'my-first-webpack.bundle.js' }, module: { rules: [ /* test 正则表达式，用于匹配进行转换的文件 */ /* use 表示所使用的loader名称 */ { test: /\\.txt$/, use: 'raw-loader' } ] }};module.exports = config; 以上代码中添加了module，在内部定义了rules，里面必须包含 test 属性，(正则表达式) 用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，使用的loader名称 它们的作用是告诉webpack编译器，在解析时发现 import xxxx.txt / require(xxx.txt) 里面有.txt的路径时，使用raw-loader进行转换 Plugins 插件插件与Loader不同的是，插件可用于执行范围更广的任务，具体是什么个东西在使用webpack之后就会渐渐了解 Plugins的配置如下 12345678910111213141516const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const config = { module: { rules: [ { test: /\\.txt$/, use: 'raw-loader' } ] }, plugins: [ /* 实例化一个对象 */ new HtmlWebpackPlugin({template: './src/index.html'}) ]};module.exports = config; 这里使用了一个叫做html-webpack-plugin的插件 首先在config里添加 123456const config = { /* ... */ plugins: [ /* ... */ ]}; 然后导入HtmlWebpackPlugin插件 1const HtmlWebpackPlugin = require('html-webpack-plugin'); 在config里new 一个实例 12345const config = { plugins: [ new HtmlWebpackPlugin({template: './src/index.html'}) ]}; 模式webpack有两种模式 development production 及开发模式和生产模式了解更多 浏览器兼容性webpack 支持所有支持ES5的浏览器(IE8 及以下不支持)如果你想支持旧版浏览器，你需要加载polyfill","link":"/blog/articles/2019-07-16-webpack-tutorial-01.html"},{"title":"Html+css+js布局设计第一弹","text":"8 Horizontal Menu2019/6/23水平菜单栏有一些简单的动画，在别的地方看见的，就照着做了下 1234567891011121314151617181920212223/* 主要也是用的 :before 伪元素来修饰图标 */nav .menu ul li:hover i:before { border-color: transparent; border-radius: 500px; width: 66px; height: 66px; line-height: 60px; transition: color 0.2s linear 0s, font-size 0.2s linear 0s, border-color 0.2s linear 0s, height 0.2s linear 0s, width 0.2s linear 0s, line-height 0.2s linear 0s;}nav .menu a i:before { border: 2px solid; border-color: #a3a7ad; border-radius: 500px; width: 41px; display: inline-block; height: 41px; line-height: 37px; transition: color 0.2s linear 0s, font-size 0.2s linear 0s, border-color 0.2s linear 0.2s, height 0.2s linear 0s, width 0.2s linear 0s, line-height 0.2s linear 0s;} 7 Responsive Design2019/6/21响应式卡片 12345678/* 图片使用绝对定位 *//* 使用odd 和 even 调整图片的位置 */.container .box:nth-child(odd) .thumb { bottom: 0;}.container .box:nth-child(even) .details { bottom: 0;} 响应式部分1234567891011@media (max-width: 1000px) { .container { width: 100%; height: auto; padding: 20px; box-sizing: border-box; } .container .box { height: 250px; }} 12345678910@media (max-width: 768px) { .container { flex-wrap: wrap; } .container .box { flex-basis: 50%; transition: transform 1s; }} 12345@media (max-width: 500px) { .container .box { flex-basis: 100%; }} 6 CSS 3d Layered Image2019/6/19鼠标 hover 出现特效 123/* 使用skew产生形变 */transform: rotate(-30deg) skew(25deg) scale(0.8);/* 添加4层layer，分别在hover的时候tranform就行了 */ 12345678910111213141516&lt;img src=\"res/CSS 3d Layered Image Hover Effects - CSS Isometric Design/screen.png\" alt=\"\"/&gt;&lt;img src=\"res/CSS 3d Layered Image Hover Effects - CSS Isometric Design/screen.png\" alt=\"\"/&gt;&lt;img src=\"res/CSS 3d Layered Image Hover Effects - CSS Isometric Design/screen.png\" alt=\"\"/&gt;&lt;img src=\"res/CSS 3d Layered Image Hover Effects - CSS Isometric Design/screen.png\" alt=\"\"/&gt; 123456789101112131415161718192021/* 每一张图片transform不同距离 *//* 给上不同透明度 */.container:hover img:nth-child(4) { transform: translate(160px, -160px); opacity: 1;}.container:hover img:nth-child(3) { transform: translate(120px, -120px); opacity: 0.8;}.container:hover img:nth-child(2) { transform: translate(80px, -80px); opacity: 0.6;}.container:hover img:nth-child(1) { transform: translate(40px, -40px); opacity: 0.4;} 5 Thanos Snap Disperison2019/6/18灭霸响指消失特效（有点 low） 1/* 原理就是使用一张noise.png的噪点图覆盖原图 */ 4 Hover expand menn2019/6/10简单的菜单栏 使用:target伪类来实现点击、未使用js 123456789/* * target为地址栏中的hash * 该用法能够使.item id=hash值的元素被选中 * 然后使他的高度为10em*/.item:target .submenu { max-height: 10em; /* overflow: scroll; */} 1-3 flex布局简单尝试2019/5/30flex布局11234567891011121314/* * flex中居中的方法 */.container { display: flex; justify-content: center; /* 在轴的方向上使元素居中 */ align-items: center; /* 垂直于flex轴居中 */ align-content: center; /* 设置了flex-wrap后，使得每一行居中于该行*/}/* * 注意 align-self 与 align-items 的取别 * align-self用于容器中的元素 * align-items用于容器 */ flex布局2 flex布局3 0 Glowing Border渐变色的边框2019/5/25该方法的巧妙之处是使用了为元素:after和:before来添加边框1234567891011121314151617181920212223242526.container:before { content: ''; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px; background-color: white; z-index: -1;}.container:after { content: ''; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px; background-color: white; z-index: -1; filter: blur(15px);}.container:before,.container:after { background: linear-gradient(235deg, #d4ffa2, #f956ff, #6aeeff);}","link":"/blog/articles/2019-07-03-html-css小技巧第一弹.html"},{"title":"使用gulp优化hexo博客，对资源进行压缩","text":"hexo生成出来的资源文件很大，全是没有压缩的，为了节约网络带宽，可以对其public目录下的js，html，css文件进行压缩。那么这里使用的工具就是强大的gulp 使用gulp对打包出的css、js、html及图片文件进行压缩 使用hexo generate指令后，会在根目录下生成网页的资源文件其目录结构如下 查看里面的内容，会发现有大量的空白 查看文件的大小:50kb 然后我们再来看看压缩后的文件大小:33kb 内容 这些多余的空白造成了文件内容冗余，造成了空间浪费，压缩后的文件都快比原来少一半了。 gulp介绍什么是gulp？ 官网介绍:Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务的 Gulp 文件都是通过 JavaScript（或者 CoffeeScript ）源码来实现的。 想要了解更多可以查看gulp官网 准备工作 没有安装npm的需安装npm 安装gulp工具 全局安装1 npm install --global gulp 12 - 作为依赖本地安装 1npm install --save-dev gulp使用方法 在项目根目录下创建gulpfile.js的文件夹 输入以下代码 12345var gulp = require('gulp');gulp.task('default', function() {// 要执行的任务}); 然后在命令行输入 gulp 就会运行task里面的任务 如果任务名字不是default，如 12345var gulp = require('gulp')gulp.task('hello', function() { console.log('你好')}) 这时需要在命令行输入 gulp hello 输出 123[00:53:12] Using gulpfile D:\\SILVER\\Documents\\GitHub\\MyHexoBlog\\gulpfile.js[00:53:12] Starting &apos;hello&apos;...你好 简短介绍后，下面进入正题 压缩文件gulp是通过插件来运作的 首先需要安装插件 123456npm install gulp-htmlclean // 压缩htmlnpm install gulp-htmlmin // 压缩html，外加去除注释，压缩css，删除多余属性等npm install gulp-clean-css // 压缩cssnpm install gulp-uglify // 压缩jsnpm install gulp-babel // 转换为es2015npm install gulp-imagemin // 压缩图片 编写gulpfile.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182let gulp = require('gulp')let cleanCSS = require('gulp-clean-css')let htmlmin = require('gulp-htmlmin')let htmlclean = require('gulp-htmlclean')let babel = require('gulp-babel') /* 转换为es2015 */let uglify = require('gulp-uglify')let imagemin = require('gulp-imagemin')// 压缩html// 设置根目录const root = './public'// 匹配模式， **/*代表匹配所有目录下的所有文件const pattern = '**/*'gulp.task('minify-html', function() { return gulp // 匹配所有 .html结尾的文件 .src(`${root}/${pattern}.html`) .pipe(htmlclean()) .pipe( htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true }) ) .pipe(gulp.dest('./public'))})// 压缩cssgulp.task('minify-css', function() { return gulp // 匹配所有 .css结尾的文件 .src(`${root}/${pattern}.css`) .pipe( cleanCSS({ compatibility: 'ie8' }) ) .pipe(gulp.dest('./public'))})// 压缩jsgulp.task('minify-js', function() { return gulp // 匹配所有 .js结尾的文件 .src(`${root}/${pattern}.js`) .pipe( babel({ presets: ['env'] }) ) .pipe(uglify()) .pipe(gulp.dest('./public'))})// 压缩图片gulp.task('minify-images', function() { return gulp // 匹配public/images目录下的所有文件 .src(`${root}/images/${pattern}`) .pipe( imagemin( [ imagemin.gifsicle({ optimizationLevel: 3 }), imagemin.jpegtran({ progressive: true }), imagemin.optipng({ optimizationLevel: 7 }), imagemin.svgo() ], { verbose: true } ) ) .pipe(gulp.dest('./public/images'))})// 如果使用的是gulp 4.0版本以下，使用下面的代码// gulp.task('default', [// 'minify-html','minify-css','minify-js'// ]);gulp.task('default', gulp.series('minify-html', 'minify-css', 'minify-js')) 注意这里使用了gulp 4.0以上的版本 使用下面代码定义指令gulp的任务队列 12// 顺序执行 minify-html -&gt; minify-css -&gt; minify-jsgulp.task('default', gulp.series('minify-html', 'minify-css', 'minify-js')) 然后在命令行输入 gulp就可以开始压缩了 12345678910$ gulp[01:09:51] Using gulpfile D:\\SILVER\\Documents\\GitHub\\MyHexoBlog\\gulpfile.js[01:09:51] Starting &apos;default&apos;...[01:09:51] Starting &apos;minify-html&apos;...[01:09:52] Finished &apos;minify-html&apos; after 924 ms[01:09:52] Starting &apos;minify-css&apos;...[01:09:52] Finished &apos;minify-css&apos; after 65 ms[01:09:52] Starting &apos;minify-js&apos;...[01:09:53] Finished &apos;minify-js&apos; after 1.16 s[01:09:53] Finished &apos;default&apos; after 2.16 s 压缩完成后使用hexo部署 1hexo deploy 一个命令搞定生成文件，压缩，部署在package.json文件中的”scripts”下添加 123\"scripts\": { \"deploy\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d\"} 然后在控制台输入 1npm run deploy 就会开始自动生成文件-&gt;压缩文件-&gt;部署到服务器","link":"/blog/articles/2019-07-05-hexo博客优化-gulp压缩-提高访问速度.html"},{"title":"webpack入门(2): 安装与使用","text":"下面就来通过例子讲解webpack的安装，基本操作 webpack 是一个用于编译Javascript模块的工具，在安装webpack之后，可以通过 CLI (command line interface 就是在控制台上使用 ) API (在js中导入模块使用) 下面介绍的是webpack-cli的使用 安装输入下面指令，意思是 创建webpack-demo文件夹 进入webpack-demo 初始化npm -y参数表示自动输入yes 安装webpack 安装webpack-cli 12345mkdir webpack-democd webpack-demonpm init -ynpm install webpack --save-devnpm install webpack-cli --save-dev 执行完之后会生成一个package.json，这是npm生成的文件，定义了这个项目所需要的各种模块,以及项目的配置信息。关于npm和package.json这里不做过多阐述 如果你想要了解 package.json 内在机制的更多信息，推荐阅读 npm 文档。 创建文件创建以下目录结构 12345 webpack-demo |- package.json+ |- index.html+ |- /src+ |- index.js 各个文件的内容如下./src/index.js 12345678910function component() { const element = document.createElement('div'); // Lodash（目前通过一个 script 脚本引入）对于执行这一行是必需的 element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element;}document.body.appendChild(component()); ./index.html 12345678910&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;script src=\"https://unpkg.com/lodash@4.16.6\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"./src/index.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ./package.json 123456789101112131415161718 { \"name\": \"webpack-demo\", \"version\": \"1.0.0\", \"description\": \"\",+ \"private\": true, - \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"webpack\": \"^4.20.2\", \"webpack-cli\": \"^3.1.2\" }, \"dependencies\": {} } private的作用是防止项目被发布 在开始使用webpack前，观察目录结构，默认情况下webpack的入口是src/index.js，index.js的执行需要依赖lodash 这在index.html体现出来， 1&lt;script src=\"https://unpkg.com/lodash@4.16.6\"&gt;&lt;/script&gt; 在index.js引入之前引入了lodash 但index.js未显式声明引入lodash，这时webpack会假定存在全局变量 _ lodash这个库的使用方式就是用 _操作，与jquery的$类似 不过这样做会有一些问题 无法立即体现，脚本的执行依赖于外部扩展库(external library)。 如果依赖不存在，或者引入顺序错误，应用程序将无法正常运行。 如果依赖被引入但是并没有使用，浏览器将被迫下载无用代码。 这时候执行 这句话意思是，执行安装在node_module的webpack控制台程序 1npx webpack 生成的文件中不会有lodash的变量_，将会报错 下面src/index.js通过webpack打包后生成的文件，默认在dist目录下 这里只有main.js 通过查看里面也没有lodash的脚本 index.html也不存在 显然我们这不是我们预期的输出 调整这里需要手动将index.html移入dist文件夹 更改script标签 123456789&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;起步&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这里删除了两个script标签，引入了main.js 1234567891011 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt;- &lt;script src=\"https://unpkg.com/lodash@4.16.6\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;- &lt;script src=\"./src/index.js\"&gt;&lt;/script&gt;+ &lt;script src=\"main.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 不过这里的main.js仍然没有引入lodash 这时候执行 1npx webpack 访问index.html查看控制台 可以看出 _没有被定义 通过npm安装lodash并通过import引入通过npm 安装lodash 1npm install --save lodash 引入到index.js 只是在第一行增加了import _ from 'lodash'; 123456789101112import _ from 'lodash';function component() { var element = document.createElement('div'); // Lodash 通过import引入 element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element; } document.body.appendChild(component()); 现在，可以打包我们的程序了 1npx webpack 执行安装在node_module的webpack控制台程序 查看页面 这说明代码已经执行，现在已经没问题了 使用配置文件这时我们已经基本了解webpack的工作流程，不过大多数情况下，都要通过webpack.config.js配置文件来控制webpack文件的入口，出口，需要用到的loader、插件 该内容将在下一章进行讲解","link":"/blog/articles/2019-07-16-webpack-tutorial-02-getting-start.html"},{"title":"webpack入门(3): 使用配置文件webpack.config.js及多入口的配置","text":"如果想修改webpack的默认入口，出口，使用的插件，loader时，可以通过控制台的webpack指令传入参数 如 1webpack --entry xxxx 来定义入口文件 但是更多的做法是创建一个webpack.config.js文件，利用这个文件对进行相关的配置 下面介绍使用webpack.config.js的基本配置以及多 使用webpack.config.js创建方式 可以手动新建文件， 也可以使用npx webpack init指令初始化配置文件 使用npx webpack init命令 在输入指令后根据提示创建配置文件 1234567891011npx webpack initi INFO For more information and a detailed description of each question, have a look at: https://github.com/webpack/webpack-cli/blob/master/INIT.mdi INFO Alternatively, run \"webpack(-cli) --help\" for usage info? Will your application have multiple bundles? No? Which will be your application entry point? src/index? In which folder do you want to store your generated bundles? dist? Will you use one of the below JS solutions? ES6? Will you use one of the below CSS solutions? CSS? Overwrite src\\index.js? overwrite 手动创建webpack.config.js 在项目根目录创建webpack.config.js 编辑文件 webpack.config.js 使用module.exports暴露模块 entry 定义入口文件 output 定义输出文件 plugins 使用的插件 module 使用的loader 12345678910111213141516171819202122232425262728const path = require('path');module.exports = { // 使用开发者模式 mode: 'development', // 定义入口 entry: './src/index.js', // 定义输出文件 output: { filename: 'main.js', path: path.resolve(__dirname, 'dist') }, /* // 定义插件 plugins: [new webpack.ProgressPlugin(), new HtmlWebpackPlugin()], // 定义loader module: { rules: [ { test: /\\.css$/i, use: ['style-loader', 'css-loader'], }, ], }, */}; 配置好之后运行npx webpack 输出 配置多个入口入口 这里使用3个js文件 webpack.config.js 12345678910111213module.exports = { // 使用对象语法定义3个入口文件 entry: { pageOne: './src/index1.js', pageTwo: './src/index2.js', pageThree: './src/index3.js' }, // 分别输出3个js文件，[name]表示对应的文件名 output: { filename: '[name].js', path: __dirname + '/dist' }}; 运行npx webpack 输出","link":"/blog/articles/2019-07-16-webpack-tutorial-03-config.html"},{"title":"webpack入门(4): loader的使用，css-loader","text":"更新中 webpack 的核心就是将资源文件打包，通过前面两章只对 webpack 进行初步的学习，也知道了如何对单个 javascript 文件进行打包，不过如果项目中包含css文件，也需要对其进行打包。 当然css可以不用打包，但是命名空间会成为问题，很多css融在一起难免会造成命名冲突，所以才会有vue、react这些框架的组件化编程思想 组件化的核心思想就是将css、javascript、html组合成一个单独的小部件，比如你做了一个相册，将代码分别写在html、css、javacript里面，当别人要用这个相册的时候就遇到问题了： 需要复制你的html相册部分元素 需要复制你的javascript 需要复制你的css样式表 在自己的工程中引入css和js 祈祷css、javascript中没有冲突 好的做法 将css、html、javascript融合到一个javascript文件作为一个模块，使用javascript生成css、html，然后别人只需要这样做： 假定这个javascript文件叫做album.js 引入album.js到&lt;script&gt;&lt;/script&gt;标签或者使用模块的方式引入到你的javascript里面 使用内部的方法，比如new album(selector) 然后就在对应的元素上创建了相册 说了这么多，下面就来学习在webpack中如何使用css-loader对css进行打包 准备工作安装安装style-loader和css-loader 12npm install --save-dev style-loader npm install --save-dev css-loader 添加文件为了做演示，这里写了一个简单的css文件 12345678910* { padding: 0; margin: 0;}body { background: darkblue; height: 100vh;} — 更新中","link":"/blog/articles/2019-07-17-webpack-tutorial-04-use-cssloader.html"},{"title":"javascript性能优化之debounce与throttle","text":"消抖(debounce): 当函数被调用后，n秒之后才会触发该函数，如果在此期间函数再次被调用，则重新开始计时，n秒之后才会触发该函数。 其作用是为了避免某个事件在短时间内连续触发从而影响性能，也可用于避免在一定时间内重复提交表单等。 节流(throttle): 函数被调用后，立即触发该函数，在之后的n秒之内不能再次重复触发。 该函数可以用于限制浏览器scroll，mousemove等高频触发事件的触发频率 下面介绍debounce和throttle的实现方式 这两种方法在lodash里已经给封装好了，下面用原生js实现 debounce利用闭包，设置一个timer： 每次执行都clearTimeout(timer) 每次执行设置timer = setTimeout()执行函数 1234567891011121314151617function debounce(func, delay) { // 存储timer let timer = null return function() { // 如果已经设置了 timer，将其清空，防止未执行的timer执行 clearTimeout(timer) timer = setTimeout(()=&gt; { // delay后执行函数，使用es6语法，给函数传入参数 let args = Array.from(arguments) // 传入this和参数 func.apply(this, args) }, delay) }} debounce实例在input事件使用debounce，减少触发次数，这里设置延迟为1秒，是不是有点像搜索引擎的提示呈现 代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" placeholder=\"debounce\"/&gt; &lt;p&gt;debounce test&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;const input = document.querySelector('input')const p = document.querySelector('p')input.addEventListener('input', debounce(function(e){ p.innerText = e.target.value}, 1000))function debounce(func, delay) { // 存储timer let timer = null return function() { // 如果已经设置了 timer，将其清空，防止未执行的timer执行 clearTimeout(timer) timer = setTimeout(()=&gt; { // delay后执行函数，使用es6语法，给函数传入参数 let args = Array.from(arguments) // 传入this和参数 func.apply(this, args) }, delay) }}&lt;/script&gt; codepen See the Pen debounce by Chen Yinyi (@CYSILVER) on CodePen. throttle利用闭包，设置一个exec记录当前函数执行状态： 若正则执行，则跳过if，直接退出函数 若没有在执行，则执行函数，设置exec为true，一段时间后置为false 1234567891011121314151617181920function throttle(func, delay) { // 记录当前函数是否正在被执行 let exec = false return function() { // 如果该函数未在执行 if (!exec){ // 执行该函数 let args = Array.from(arguments) func.apply(this, args) // 设置执行为true exec = true // 在delayh后设置为false setTimeout(()=&gt;{ exec = false }, delay) } }} throttle实例这里同样使用上面的例子，看看有什么区别 使用throttle，设置1秒只能触发一次 如果还看不出区别，请看下图 使用debounce ，设置延迟为1秒 很明显了对吧 不过throttle一般不用于这里，一般用于scroll，mousemove等触发频率很高的事件，对其进行限制 codepen See the Pen throttle by Chen Yinyi (@CYSILVER) on CodePen. 以上就是对debounce和throttle的介绍，希望能帮助到大家","link":"/blog/articles/2019-07-28-debounce.html"},{"title":"ES6新特性之Map、Set与WeakMap、WeakSet的区别","text":"ES6提供了新的数据结构Set，类似于数组，不过里面不会出现重复的值 另外一个是Map，类似于对象，对象只能使用字符串作为键，而Map可以使用任意类型 回顾下Map和Set 简要总结如下： Map 与 Object 一样，本质上是Hash结构 可以使用各种类型作为key Object 只能使用字符串作为key 12345678910111213// 使用数组作为keylet o = [1,2,3]let b = [1,2,3]let map = new Map()map.set(o, 'foo')map.set(b, 'bar')// 虽然使用了相同的数组，但数组的内存地址不一样，所以key不一样console.log(map.get(o)) // 'foo'console.log(map.get(b)) // 'bar'// 而使用对象就不能用上面的方法，对象的key只能使用字符串let obj = { [1,2,3]: 'foo' //会报语法错误} Set 与数组类似 成员唯一，没有重复值 12345678910let set = new Set([1,1,1,2,3,4])for (let item of set) { console.log(item)}// 1// 2// 3// 4// 去掉了重复的1 WeakMap和WeakSet与Map和Set的主要区别就是： WeakSet 对象中只能存放对象引用，不能存放原始数据（如数字 1) WeakSet 对象中存储的对象值都是被弱引用的，如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉。 WeakMap 中的key只是对象引用，不能是 原始数据类型 WeakMap 持有的是每个键或值对象的弱引用，如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉。 WeakMap 的key和 WeakSet 的元素是不可枚举的，因为他们存储的对象都是被弱引用的，如果能被枚举，会受垃圾回收机制的影响出现不确定性的结果 举个例子 如果使用的是Map 123const div = document.querySelector('div')let map = new Map()map.set(div, 'foo') 上面div是一个对象，map中以div为key，形成了对div对象的引用 如果我们不再需要这个对象，就必须手动解除引用，不然就不会对div的内存进行清理 12div = null // 不再需要这个对象map.delete(div) // 手动解除map中的引用 而如果使用了WeakMap 123const div = document.querySelector('div')let weakmap = new WeakMap()weakmap.set(div, 'foo') 如果我们不再需要这个对象，由于WeakMap是弱引用，所以垃圾回收机制会清理掉div的内存 12div = null // 不再需要这个对象// weakmap.delete(div) 不用手动解除","link":"/blog/articles/2019-07-26-WeakSet-WeakMap.html"},{"title":"清除浮动解决方案，使用.clearfix类选择器","text":"这个东西其实很简单 使用css 12345.clearfix::after { display: block; content: \"\"; clear: both;} 直接把要清除浮动的添加clearfix就行了 演示html 123&lt;div class=\"container\"&gt; &lt;div class=\"floated\"&gt;floated&lt;/div&gt;&lt;/div&gt; css 123456789101112131415161718.clearfix::after { display: block; content: ''; clear: both;}div { border: 1px dashed skyblue;}.container { width: 200px; background: rgb(83, 152, 197);}.floated { height: 300px; float: left; background: rgb(224, 173, 107);} 容器未被撑开 添加clearfix 123&lt;div class=\"container clearfix\"&gt; &lt;div class=\"floated\"&gt;floated&lt;/div&gt;&lt;/div&gt; 容器被撑开，浮动清除 clearfix还可以加入flow-root属性 123456789101112131415.clearfix::after { display: block; content: \"\"; clear: both;}/* 如果浏览器支持 flow-root属性 */@supports(display: flow-root) { .clearfix::after { display: none; } .clearfix { display: flow-root } } 关于flow-root，我的这篇文章有讲解","link":"/blog/articles/2019-07-30-clearfix.html"},{"title":"es6中Promise.all、Promise.race的实现及其用法","text":"灵魂配图 在es6中，新增了Promise对象 其中有两个方法 Promise.all() Promise.race() 都是用于将多个Promise实例包装成另一个实例 下面我会对两种方法进行介绍，以及自己使用js实现他们的方法 Promise.all()接受一个数组，返回Promise对象： let p = Promise.all([p1, p2, p3]) 当p1,p2,p3的状态都变为fulfilled，其p的状态才变为fulfilled。p1,p2,p3的resolve值组成数组传递给p的resolve值 p1,p2,p3中有一个状态变为rejected，那么p的状态变为rejected，reject的值为该promise的reject值 看个例子就懂了如下面代码，Promise.all的resolve值为['p1', 'p2'] 1234567891011121314151617let p1 = new Promise((resolve) =&gt; { // 模拟异步 setTimeout(() =&gt; { resolve('p1') }, 3000)})let p2 = new Promise((resolve) =&gt; { // 模拟异步 setTimeout(() =&gt; { resolve('p2') }, 2000)})Promise.all([p1, p2]).then((res) =&gt; { console.log(res) // 输出['p1', 'p2']}) 123456789let p3 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject('p3') }, 1500)})Promise.all([p2, p3]).then(null, (res) =&gt; { console.log(res) // 输出'p3'}) 实现方式代码如下，要点都写在注释里了 1234567891011121314151617181920212223242526function PromiseAll(arr) { // 把每个resolve的结果存放在result let result = [] // 记录arr的长度 let length = arr.length let curlength = 0 return new Promise((resolve, reject) =&gt; { arr.forEach((p, index) =&gt; { // 使用 Promise.resolve()将不是Promise对象转换为Promise对象 // 调用每一个promise对象的then方法 Promise.resolve(p).then((res) =&gt; { // 调用之后将结果存入result result[index] = res curlength++ // 判断是否全部执行完毕 if (result.length === curlength) { resolve(result) } // 如果出错，直接reject }, (err) =&gt; { reject(err) }) }); })} Promise.race()接受一个数组，返回Promise对象： let p = Promise.race([p1, p2, p3]) 当p1,p2,p3中最先变为fulfill或者rejected的Promise对象的reject或resolve值，就为p的reject或resolve值 看个例子就懂了下面代码p2状态更快变为fulfilled输出值为p2 1234567891011121314151617let p1 = new Promise((resolve) =&gt; { // 模拟异步 setTimeout(() =&gt; { resolve('p1') }, 3000)})let p2 = new Promise((resolve) =&gt; { // 模拟异步 setTimeout(() =&gt; { resolve('p2') }, 2000)})Promise.race([p1, p2]).then((res) =&gt; { console.log(res) // 'p2'}) 实现方式该方法要比all简单 1234567891011121314function PromiseRace(arr) { return new Promise((resolve, reject) =&gt; { arr.forEach((p, index) =&gt; { // 使用 Promise.resolve()将不是Promise对象转换为Promise对象 // 调用每一个promise对象的then方法 // 之后直接resolve或reject Promise.resolve(p).then(result =&gt; { resolve(result) }, (err) =&gt; { reject(err) }) }) })} 总结以上就是Promise.all和Promise.race的介绍以及源码实现。 还是比较简单，不过有个注意的点就是使用Promise.resolve(p)将非Promise对象转为Promise对象，这样才能调用then方法","link":"/blog/articles/2019-07-30-promise-all-race.html"},{"title":"CSS动画-auto属性的过渡","text":"通常，你想要通过css transition来过渡属性，然后使用了下面代码transition: height 0.5s linear 然后又使用了 height: auto来自适应高度height: 0 -&gt; height: auto 然后发现动画就像没发生一样，直接就在0和auto两个状态之间直接切换 你可能会认为出现了什么bug，或者代码写错了，其实不然 你可能发生下图所示的情况 在这篇文章中，都使用高度进行说明，这张图里的宽度与高度是一个道理 这个问题目前还不能简单通过css完全解决 下面是我分享的4个解决方案 本文章部分资料以及Code Pen代码引用于 css-tricks.com， 里面有很多关于css的技巧，值得学习 这是浏览器bug?查阅Mozilla Developer Network docs， auto 属性值被排除在transition规范之外。 这样做的原因是因为，如果transition一个元素的高度到auto，浏览器将会进行页面重排(reflow)，重排页面会计算其他元素的位置，并且在每一个动画帧都会进行这样的操作，这意味着将花费巨大的开销。 虽然设置height: auto达到不了我们想要的效果，但是可以通过其他方法实现，下面介绍4种方式 使用max-height 使用transform: scaleY() 使用Javascript 使用Flex容器 解决方案 1: 使用 max-height这个方法可能是最容易搜索到的方法，但是不太理想，不过在一些情况下，还是值得使用 具体方法大概如下： ​ 设置 transition: max-height 0.3s ease-out ​ max-height: 0 ​ 过渡到一个该容器能达到的最大值，比如 1000px ​ max-height: 1000px 这里的max-height必须保证大于容器auto的height，不然就会出现内容显示不全的情况 Code Pen演示 在以下的code pen演示中都使用的SCSS，如果需查看CSS，请点击下面的View Compiled按钮 主要注意.section这部分 123456789.section { overflow:hidden; transition:max-height 0.3s ease-out; /* 设置max-height的transition属性 */ height:auto; max-height:600px; /* 这里仍然需要硬编码 */}.section.collapsed { max-height:0;} See the Pen Smooth Collapsing div with max-height by Chen Yinyi (@CYSILVER) on CodePen. 缺点可能你也发现了，这里的max-height也是硬编码，大多数情况下也不好确定容器的最大内容高度。 其次，设置的transition的时间和变换函数和实际展示出来的并不一致 打个比方 ​ 内容的实际最高宽度为100px ​ 你设置了: ​ max-height: 0 -&gt; max-height: 1000px ​ transition: max-height 10s linear; ​ 那么这里的10s的transition显示在浏览器上就只有1s，因为1s后max-height: 100px已经达到容器最大高度，后面的max-height的变化不会体现出来 ​ 解决方案 2: transform: scaleY()该方法不会触发页面重排(reflow) 设置方法很简单 设置 transform: scaleY(0) 到 transform: scaleY(1) 即可完成高度的缩放 该方法不会触发重排，所以元素位置不会改变，同时元素的内容会产生挤压的形变效果 Code Pen 演示12345678910.section { overflow:hidden; transition:transform 0.3s ease-out; /* 设置transform的transition属性 */ height:auto; transform:scaleY(1); /* 可以不用显示声明，但最好的做法是在这里声明一下 */ transform-origin:top; /* 设置transform的起始点，不然就会从中间开始缩放 */}.section.collapsed { transform:scaleY(0); /* 设置为0 */} See the Pen Smooth Collapsing div with scaleY() by Chen Yinyi (@CYSILVER) on CodePen. 缺点该方法普遍不适用 产生的形变效果大部分时候不是我们想要的，也不够没关 不会产生页面重排，折叠后的位置留空，大部分时候不是我们想要的情况 解决方案 3: Javascript（推荐）该方法使用js获取到内容的最大高度，然后就能使用固定的高度进行transition了 基本思路是使用，获取到元素的高度 1element.scrollHeight 然后设置 1element.style.height = scrollHeight 点击后设置 1element.style.height = 0 这样就能实现css的transition效果，并且移除了硬编码，更加灵活，适用于任意高度的容器 Code Pen 演示要点在这两部分 12var sectionHeight = element.scrollHeight; // 获取到内容的高度element.style.height = sectionHeight + 'px'; // 设置Height 关于scrollHeight Element.scrollHeight 这个只读属性是一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容。 我这里放个图大家就知道了 See the Pen Smooth Collapsing div with Javascript by Chen Yinyi (@CYSILVER) on CodePen. 这里使用到了requestAnimationFrame()，关于这个我会在之后的博文讲解。 下面是我写的另外一种做法，比这个要直观一点 12345678910111213141516171819document.querySelectorAll('.dropdown-nav__title').forEach((item, index) =&gt; { item.addEventListener( 'click', (function(event) { // 利用闭包存储状态 let opened = false return function(event) { let scrollHeight = event.target.nextElementSibling.scrollHeight requestAnimationFrame(() =&gt; { // 切换height event.target.nextElementSibling.style.height = opened ? '0' : `${scrollHeight}px` opened = !opened }) } })() //立即执行函数，返回内部的function ) }) See the Pen dropDown-menu by Chen Yinyi (@CYSILVER) on CodePen. 缺点同样的，这里没有避免掉页面重排的问题 不过在某些特定的情况下，可以通过使用绝对定位来避免页面重排，比如导航栏的下拉菜单如果需要设置动画，就不需要重排页面。 解决方案 4: FlexBox (额外方式)之所以称之为额外方式，是因为从技术上来说该方式没有达到预期的效果，不过却是另外一种不错的方法 如果你还不够了解flexbox 和 flex-grow两个属性，推荐阅读 阮一峰的Flex 布局教程 A Complete Guide to FlexBox (英文) 这里的话主要就是用到的flex这个属性了(实质上为flex-grow) Code Pen 演示123456789.section { overflow:hidden; /* 注意这里是关键 */ transition:flex 0.3s ease-out; /* 设置flex的transition */ height:auto; flex:1; /* 设置flex为1，或者1以上，即容器能够自动伸长，关于这个值的作用请见flexbox的教程 */}.section.collapsed { flex: 0; /* 设置flex为0，即容器不会自动伸长 */} 请注意上面的 1overflow: hidden; 这句话是关键，可替换为 1min-height: 0; 因为默认情况下，元素不会缩短至小于内容框尺寸，若想改变这一状况，请设置元素的min-width与 min-height属性。同样的设置overflow: hidden也可达到相同效果 See the Pen Smooth Collapsing div with Flexbox by Chen Yinyi (@CYSILVER) on CodePen. 这又是另一种效果，所以说是一种额外的解决方法。 不过这种方法利用了flexbox，更加灵活 总结这四种方式各有优缺点，没有优劣，不过个人还是比较喜欢用js的方式，不过至于到底该用哪个，根据你的需求和情况而定。","link":"/blog/articles/2019-07-29-CSS动画-auto属性的过渡.html"},{"title":"了解css中的block formatting context(块级上下文) 以及 display: flow-root","text":"块级上下文挺起来很抽象，W3C 中是这样解释的： floats, absolute定位, 不是块级元素的块级容器(列如inline-block, table-cells, table-captions)，以及display为overflow等不是visible属性的元素，会为它们包含的内容建立新的block formatting context 在block formatting context中，以容器的顶端为开始，Box一个接一个的垂直排列，两个相邻box之间的距离由margin决定，在相同的block formatting context中，两个相邻的块级Box会产生外边距合并 (这是重点) 在block formatting context中，每一个Box的左边界紧挨着容器左边界(如果是从右到左的布局，那么触碰到右边界)。 在floats元素依然满足此要求(但是Box内的行框由于float可能会变窄)，除非建立了新的block formatting context(这种情况下box会由于float元素而变窄) 上面的话可以总结为： block formatting context就是页面上的一个隔离的独立容器，容器内的子元素不会影响到外面的元素。反之如此 看了这么多，是不是感觉很抽象，没关系，我们与其去研究这些抽象的文字，不如来看看block formatting context能做什么。 了解BFC(Block Formatting Context)块级上下文BFC的创建通过上面的介绍可以知道，设置display、position、float、overflow均可以为元素创建BFC 这里设置overflow: hidden，这样就创建了bfc 123&lt;div class=\"container\"&gt; Some Content here&lt;/div&gt; 123.container { overflow: hidden;} 外边距合并同一个BFC里面的相邻元素会产生外边距合并 如下，设置的p的上下外边距为10px，合并后仍为10px 1234&lt;div class=\"container\"&gt; &lt;p&gt;Sibling 1&lt;/p&gt; &lt;p&gt;Sibling 2&lt;/p&gt;&lt;/div&gt; 123456789.container { background: orange; overflow: hidden;}p { background: skyblue; margin: 10px 0;} 了解了BFC能做些什么？下面介绍使用bfc 阻止外边距合并 清除浮动 防止文字环绕 下面一起来看看吧 阻止外边距合并让两个元素不在同一个BFC中就可以阻止外边距合并 下面将Sibling 3的容器设置为新的BFC，第三个p和第二个p的外边距就不会合并 1234567&lt;div class=\"container\"&gt; &lt;p&gt;Sibling 1&lt;/p&gt; &lt;p&gt;Sibling 2&lt;/p&gt; &lt;div class=\"newBFC\"&gt; &lt;p&gt;Sibling 3&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112 .container { background: orange; overflow: hidden;}p { background: skyblue; margin: 10px 0;}.newBFC { overflow: hidden;} Demo See the Pen prevent margin collapse by Chen Yinyi (@CYSILVER) on CodePen. ## 清除浮动 设置BFC能够清除浮动 BFC中的子元素不会影响外部元素，所以在BFC中，容器能够撑开包含浮动元素，所以设置bfc能够实现清除浮动 1234&lt;div class=\"container\"&gt; &lt;div&gt;Sibling 1&lt;/div&gt; &lt;div&gt;Sibling 2&lt;/div&gt;&lt;/div&gt; 12345678910.container { background: orange; overflow: hidden;}div { float: left; background: skyblue; margin: 10px;} Demo See the Pen bfc clear float by Chen Yinyi (@CYSILVER) on CodePen. 防止文字环绕首先我们再回顾下上面的BFC描述: 在block formatting context中，每一个Box的左边界紧挨着容器左边界(如果是从右到左的布局，那么触碰到右边界)。 在floats元素依然满足此要求(但是Box内的行框由于float可能会变窄)，除非建立了新的block formatting context(这种情况下box会由于float元素而变窄) 也就是说在默认情况下，float元素盖在p上面后，文字的行框会由于float变窄，所以就会产生文字环绕的现象。由于bfc的特性：内部布局不会影响到外部，反之如此，通过给段落&lt;p&gt;建立bfc，就能实现阻止文字环绕的效果 下面的代码给p元素设置了overflow: hidden，创建了bfc，最终实现防止文字环绕 1234&lt;div class=\"container\"&gt; &lt;div class=\"floated\"&gt;I'm floated&lt;/div&gt; &lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Hic modi laudantium unde qui tenetur labore. Dolor quaerat soluta nobis facere, obcaecati temporibus consectetur illo atque. Non excepturi voluptates ducimus odit?&lt;/p&gt;&lt;/div&gt; 123456789101112131415.container { background: orange; width: 200px;}div { float: left; background: skyblue; margin: 10px;}p { border: 1px solid green; overflow: hidden;} Demo See the Pen bfc clear text wrap by Chen Yinyi (@CYSILVER) on CodePen. 设置display: flow-root设置元素属性display: flow-root可以为元素创建新的bfc 它不像overflow: hidden那样会将溢出内容隐藏 也不会像overflow: scroll那样会产生滚动条 它就是单纯的创建bfc 通过这样的理解，你就能明白这个属性能干什么了，上面所讲的列子，都能通过设置display: flow-root 阻止外边距合并 清除浮动 防止文字环绕 对于[浏览器支持情况 ]([https://caniuse.com/#search=display%3A%20flow-root](https://caniuse.com/#search=display%3A flow-root)) 现阶段有部分浏览器不支持此属性 列如上图中的IE、Opera Mini、 IOS Safari等 总结​ 对于BFC的定义及使用就介绍到这里了，当初看那些bfc的文章介绍的时候，都是统统给你搬出来一堆概念，咬文嚼字看完几遍后依旧看不懂。最后我改变了学习方向，与其去深究定义，不如去看看它能够做什么。你问我bfc的严格定义，我可能也不能好好的回答上来，不过掌握了这些方法，相信你会对bfc有了新的理解。 ​ 我想说的是，学习不要卡在一个死胡同，定义看不懂，就多去实践，看看有什么效果，再返回去理解定义的内容，这样也许会帮助你更快的理解，同时留下的印象也就更深。","link":"/blog/articles/2019-07-31-bfc.html"}],"tags":[{"name":"bug","slug":"bug","link":"/blog/tags/bug/"},{"name":"vim","slug":"vim","link":"/blog/tags/vim/"},{"name":"vscode","slug":"vscode","link":"/blog/tags/vscode/"},{"name":"javascript","slug":"javascript","link":"/blog/tags/javascript/"},{"name":"dom","slug":"dom","link":"/blog/tags/dom/"},{"name":"webpack","slug":"webpack","link":"/blog/tags/webpack/"},{"name":"html","slug":"html","link":"/blog/tags/html/"},{"name":"css","slug":"css","link":"/blog/tags/css/"},{"name":"js","slug":"js","link":"/blog/tags/js/"},{"name":"gulp","slug":"gulp","link":"/blog/tags/gulp/"},{"name":"博客优化","slug":"博客优化","link":"/blog/tags/博客优化/"},{"name":"es6","slug":"es6","link":"/blog/tags/es6/"},{"name":"animation","slug":"animation","link":"/blog/tags/animation/"},{"name":"css动画","slug":"css动画","link":"/blog/tags/css动画/"}],"categories":[{"name":"github","slug":"github","link":"/blog/categories/github/"},{"name":"javascript","slug":"javascript","link":"/blog/categories/javascript/"},{"name":"webpack系列教程","slug":"webpack系列教程","link":"/blog/categories/webpack系列教程/"},{"name":"布局","slug":"布局","link":"/blog/categories/布局/"},{"name":"gulp","slug":"gulp","link":"/blog/categories/gulp/"},{"name":"dom","slug":"javascript/dom","link":"/blog/categories/javascript/dom/"},{"name":"es6","slug":"javascript/es6","link":"/blog/categories/javascript/es6/"},{"name":"css","slug":"css","link":"/blog/categories/css/"}]}