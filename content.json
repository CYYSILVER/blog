{"pages":[{"title":"about","text":"自我介绍 a b aa aa bb aa aa","link":"/blog/about/index.html"},{"title":"categories","text":"","link":"/blog/categories/index.html"},{"title":"tags","text":"","link":"/blog/tags/index.html"}],"posts":[{"title":"使用原生JS实现wrap与unwrap","text":"jquery中提供了.wrap()与.unwrap()方法下面介绍一下原生js的实现方法 使用原生JS实现wrap 创建包裹的元素 在被包裹的节点前插入元素 将该节点移入包裹节点 js代码如下 12345678var wrapper = document.createElement('div')var el = document.querySelector('.wrap-me')// 在该节点前插入wrapperel.parentElement.insertBefore(wrapper, inner)// 将该节点移入wrapperwrapper.appendChild(el) HTML代码 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"outer\"&gt; &lt;div class=\"wrap-me\"&gt;this is inner text&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;var wrapper = document.createElement('div')var el = document.querySelector('.wrap-me')// 在该节点前插入wrapperel.parentElement.insertBefore(wrapper, inner)// 将该节点移入wrapperwrapper.appendChild(el)&lt;/script&gt; 使用原生JS实现unwrap 将所有元素移出该元素 删除该元素 JS代码如下 123456789101112var wrapper = document.querySelector('.wrapper li')function unwrap(ele) { /* 父元素引用 */ const parent = ele.parentElement /* 如果存在子元素，将其移出 */ while(ele.firstChild) { parent.insertBefore(ele.firstChild, ele) } /* 删除该元素 */ parent.removeChild(ele)}unwrap(wrapper) HTML代码如下 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=5, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;ul class=\"wrapper\"&gt; &lt;li class=\"wrapper\"&gt; &lt;p&gt;I' m inside element&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;I' m outside element&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt;var wrapper = document.querySelector('.wrapper li')function unwrap(ele) { const parent = ele.parentElement while(ele.firstChild) { parent.insertBefore(ele.firstChild, ele) }}unwrap(wrapper)&lt;/script&gt;","link":"/blog/articles/2019-07-02-使用原生JS实现wrap与unwrap.html"},{"title":"Html+css+js布局设计第一弹","text":"8 Horizontal Menu2019/6/23水平菜单栏有一些简单的动画，在别的地方看见的，就照着做了下 1234567891011121314151617181920212223/* 主要也是用的 :before 伪元素来修饰图标 */nav .menu ul li:hover i:before { border-color: transparent; border-radius: 500px; width: 66px; height: 66px; line-height: 60px; transition: color 0.2s linear 0s, font-size 0.2s linear 0s, border-color 0.2s linear 0s, height 0.2s linear 0s, width 0.2s linear 0s, line-height 0.2s linear 0s;}nav .menu a i:before { border: 2px solid; border-color: #a3a7ad; border-radius: 500px; width: 41px; display: inline-block; height: 41px; line-height: 37px; transition: color 0.2s linear 0s, font-size 0.2s linear 0s, border-color 0.2s linear 0.2s, height 0.2s linear 0s, width 0.2s linear 0s, line-height 0.2s linear 0s;} 7 Responsive Design2019/6/21响应式卡片 12345678/* 图片使用绝对定位 *//* 使用odd 和 even 调整图片的位置 */.container .box:nth-child(odd) .thumb { bottom: 0;}.container .box:nth-child(even) .details { bottom: 0;} 响应式部分1234567891011@media (max-width: 1000px) { .container { width: 100%; height: auto; padding: 20px; box-sizing: border-box; } .container .box { height: 250px; }} 12345678910@media (max-width: 768px) { .container { flex-wrap: wrap; } .container .box { flex-basis: 50%; transition: transform 1s; }} 12345@media (max-width: 500px) { .container .box { flex-basis: 100%; }} 6 CSS 3d Layered Image2019/6/19鼠标 hover 出现特效 123/* 使用skew产生形变 */transform: rotate(-30deg) skew(25deg) scale(0.8);/* 添加4层layer，分别在hover的时候tranform就行了 */ 12345678910111213141516&lt;img src=\"res/CSS 3d Layered Image Hover Effects - CSS Isometric Design/screen.png\" alt=\"\"/&gt;&lt;img src=\"res/CSS 3d Layered Image Hover Effects - CSS Isometric Design/screen.png\" alt=\"\"/&gt;&lt;img src=\"res/CSS 3d Layered Image Hover Effects - CSS Isometric Design/screen.png\" alt=\"\"/&gt;&lt;img src=\"res/CSS 3d Layered Image Hover Effects - CSS Isometric Design/screen.png\" alt=\"\"/&gt; 123456789101112131415161718192021/* 每一张图片transform不同距离 *//* 给上不同透明度 */.container:hover img:nth-child(4) { transform: translate(160px, -160px); opacity: 1;}.container:hover img:nth-child(3) { transform: translate(120px, -120px); opacity: 0.8;}.container:hover img:nth-child(2) { transform: translate(80px, -80px); opacity: 0.6;}.container:hover img:nth-child(1) { transform: translate(40px, -40px); opacity: 0.4;} 5 Thanos Snap Disperison2019/6/18灭霸响指消失特效（有点 low） 1/* 原理就是使用一张noise.png的噪点图覆盖原图 */ 4 Hover expand menn2019/6/10简单的菜单栏 使用:target伪类来实现点击、未使用js 123456789/* * target为地址栏中的hash * 该用法能够使.item id=hash值的元素被选中 * 然后使他的高度为10em*/.item:target .submenu { max-height: 10em; /* overflow: scroll; */} 1-3 flex布局简单尝试2019/5/30flex布局11234567891011121314/* * flex中居中的方法 */.container { display: flex; justify-content: center; /* 在轴的方向上使元素居中 */ align-items: center; /* 垂直于flex轴居中 */ align-content: center; /* 设置了flex-wrap后，使得每一行居中于该行*/}/* * 注意 align-self 与 align-items 的取别 * align-self用于容器中的元素 * align-items用于容器 */ flex布局2 flex布局3 0 Glowing Border渐变色的边框2019/5/25该方法的巧妙之处是使用了为元素:after和:before来添加边框1234567891011121314151617181920212223242526.container:before { content: ''; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px; background-color: white; z-index: -1;}.container:after { content: ''; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px; background-color: white; z-index: -1; filter: blur(15px);}.container:before,.container:after { background: linear-gradient(235deg, #d4ffa2, #f956ff, #6aeeff);}","link":"/blog/articles/2019-07-03-html-css小技巧第一弹.html"},{"title":"VscodeVim 遇到的奇葩bug","text":"bug已经提交至githubhttps://github.com/VSCodeVim/Vim/issues/3864当使用插件VscodeVim和auto rename tag，新建文件在第一行输入： 1&lt;% if(get_config(&apos;toc&apos;) === true &amp;&amp; (post.layout === &apos;page&apos; || post.layout === &apos;post&apos; )) { 输入到第三个 ‘===’ 的时候编辑器就会开始卡，输入一个字符很卡，但是能正常进行其他操作太奇葩了关掉其中任意一个插件都能够正常运行 Bub 描述 操作系统: Windows 10 1903 Vscode 插件: VscodeVim, Auto Rename Tag Vscode 版本: 1.36.0 问题: 在文件中输入以下的代码会卡住键盘不能输入，但是仍然能够使用方向键移动光标 1&lt;% if(get_config(&apos;toc&apos;) === true &amp;&amp; (post.layout === &apos;page&apos; || post.layout === &apos;post&apos; )) { 在输入第三个 “===” 会产生卡顿 卡顿后仍然能够移动光标 只有在安装过vim和auto rename tag 插件后才会有冲突 Actually I’m really confused how it would work, Are my PC broken… 说实话我真不知道这玩意的原理是什么，开始我怀疑我系统问题，后来找了几个朋友测试都这样。真实个奇葩的问题 重现bugSteps to reproduce the behavior:步骤 打开Vscodej 按Ctrl+Shift+P 打开command line 输入ext: disable all 选择 Extensions: Disable All Installed Extensions 点击左侧插件 安装 vim 和 auto rename tag 插件 (两个都得启用) 创建新文件命名为 “test” (命名随便) 打开文件, 按i进入vim插入模式 输入以下的代码 *(! 注意不能忽视空格 ) *&lt;% if(get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post' )) { Expected behavior当输入到第三个 “===” 的时候就会开始卡顿 会明显感受到输入延迟, 有种打不动字的感觉 当完成输入后, 按backspace退格也会产生相同的感觉 卡顿时可能无法输入任何文字, 但能够使用方向键移动 Screenshots 运行环境 Running Extensions Node Debug Auto-attach Emmet Git Merge Conflict Auto Rename Tag 0.1.0 Vim Extension (VsCodeVim) version: 1.8.1 VSCode version: 1.36.0 OS: Windows 10 1903 提交原文Describe the bug System: Windows 10 1903 Vscode Plugins: VscodeVim, Auto Rename Tag Vscode Version: 1.36.0 bug: type the following code in a line will likely freeze your keyboard but you still can move caret with arrow key. 1&lt;% if(get_config(&apos;toc&apos;) === true &amp;&amp; (post.layout === &apos;page&apos; || post.layout === &apos;post&apos; )) { You will get stuttering when you type to the third “===” You can still move your caret when you get stuttering You can only produce the behavior when you installed both vim and auto rename tag extensions Actually I’m really confused how it would work, Are my PC broken… To ReproduceSteps to reproduce the behavior: Open Vscode Press Ctrl+Shift+P open command line Type ext: disable all Select Extensions: Disable All Installed Extensions Go to Extensions Install vim and auto rename tag (both should be enabled) Create a new file named “test” In the file, press i enter the vim insert mode Type the following code (! Can not ignore spaces)&lt;% if(get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post' )) { Expected behaviorWhen reach the third “===” stuttering would occur you can continue type but it feel lag and stutter when you finished and press backspace produce the same behavior you may can’t type any word but you can still move your caret with arrow key Screenshots Environment Running Extensions Node Debug Auto-attach Emmet Git Merge Conflict Auto Rename Tag 0.1.0 Vim Extension (VsCodeVim) version: 1.8.1 VSCode version: 1.36.0 OS: Windows 10 1903","link":"/blog/articles/2019-07-05-VscodeVim-bug.html"},{"title":"使用gulp优化hexo博客，对资源进行压缩","text":"hexo生成出来的资源文件很大，全是没有压缩的，为了节约网络带宽，可以对其public目录下的js，html，css文件进行压缩。那么这里使用的工具就是强大的gulp 使用gulp对打包出的css、js、html及图片文件进行压缩 使用hexo generate指令后，会在根目录下生成网页的资源文件其目录结构如下 查看里面的内容，会发现有大量的空白 查看文件的大小:50kb 然后我们再来看看压缩后的文件大小:33kb 内容 这些多余的空白造成了文件内容冗余，造成了空间浪费，压缩后的文件都快比原来少一半了。 gulp介绍什么是gulp？ 官网介绍:Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务的 Gulp 文件都是通过 JavaScript（或者 CoffeeScript ）源码来实现的。 想要了解更多可以查看gulp官网 准备工作 没有安装npm的需安装npm 安装gulp工具 全局安装1 npm install --global gulp 12 - 作为依赖本地安装 1npm install --save-dev gulp使用方法 在项目根目录下创建gulpfile.js的文件夹 输入以下代码 12345var gulp = require('gulp');gulp.task('default', function() {// 要执行的任务}); 然后在命令行输入 gulp 就会运行task里面的任务 如果任务名字不是default，如 12345var gulp = require('gulp')gulp.task('hello', function() { console.log('你好')}) 这时需要在命令行输入 gulp hello 输出 123[00:53:12] Using gulpfile D:\\SILVER\\Documents\\GitHub\\MyHexoBlog\\gulpfile.js[00:53:12] Starting &apos;hello&apos;...你好 简短介绍后，下面进入正题 压缩文件gulp是通过插件来运作的 首先需要安装插件 123456npm install gulp-htmlclean // 压缩htmlnpm install gulp-htmlmin // 压缩html，外加去除注释，压缩css，删除多余属性等npm install gulp-clean-css // 压缩cssnpm install gulp-uglify // 压缩jsnpm install gulp-babel // 转换为es2015npm install gulp-imagemin // 压缩图片 编写gulpfile.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182let gulp = require('gulp')let cleanCSS = require('gulp-clean-css')let htmlmin = require('gulp-htmlmin')let htmlclean = require('gulp-htmlclean')let babel = require('gulp-babel') /* 转换为es2015 */let uglify = require('gulp-uglify')let imagemin = require('gulp-imagemin')// 压缩html// 设置根目录const root = './public'// 匹配模式， **/*代表匹配所有目录下的所有文件const pattern = '**/*'gulp.task('minify-html', function() { return gulp // 匹配所有 .html结尾的文件 .src(`${root}/${pattern}.html`) .pipe(htmlclean()) .pipe( htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true }) ) .pipe(gulp.dest('./public'))})// 压缩cssgulp.task('minify-css', function() { return gulp // 匹配所有 .css结尾的文件 .src(`${root}/${pattern}.css`) .pipe( cleanCSS({ compatibility: 'ie8' }) ) .pipe(gulp.dest('./public'))})// 压缩jsgulp.task('minify-js', function() { return gulp // 匹配所有 .js结尾的文件 .src(`${root}/${pattern}.js`) .pipe( babel({ presets: ['env'] }) ) .pipe(uglify()) .pipe(gulp.dest('./public'))})// 压缩图片gulp.task('minify-images', function() { return gulp // 匹配public/images目录下的所有文件 .src(`${root}/images/${pattern}`) .pipe( imagemin( [ imagemin.gifsicle({ optimizationLevel: 3 }), imagemin.jpegtran({ progressive: true }), imagemin.optipng({ optimizationLevel: 7 }), imagemin.svgo() ], { verbose: true } ) ) .pipe(gulp.dest('./public/images'))})// 如果使用的是gulp 4.0版本以下，使用下面的代码// gulp.task('default', [// 'minify-html','minify-css','minify-js'// ]);gulp.task('default', gulp.series('minify-html', 'minify-css', 'minify-js')) 注意这里使用了gulp 4.0以上的版本 使用下面代码定义指令gulp的任务队列 12// 顺序执行 minify-html -&gt; minify-css -&gt; minify-jsgulp.task('default', gulp.series('minify-html', 'minify-css', 'minify-js')) 然后在命令行输入 gulp就可以开始压缩了 12345678910$ gulp[01:09:51] Using gulpfile D:\\SILVER\\Documents\\GitHub\\MyHexoBlog\\gulpfile.js[01:09:51] Starting &apos;default&apos;...[01:09:51] Starting &apos;minify-html&apos;...[01:09:52] Finished &apos;minify-html&apos; after 924 ms[01:09:52] Starting &apos;minify-css&apos;...[01:09:52] Finished &apos;minify-css&apos; after 65 ms[01:09:52] Starting &apos;minify-js&apos;...[01:09:53] Finished &apos;minify-js&apos; after 1.16 s[01:09:53] Finished &apos;default&apos; after 2.16 s 压缩完成后使用hexo部署 1hexo deploy 一个命令搞定生成文件，压缩，部署在package.json文件中的”scripts”下添加 123\"scripts\": { \"deploy\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d\"} 然后在控制台输入 1npm run deploy 就会开始自动生成文件-&gt;压缩文件-&gt;部署到服务器","link":"/blog/articles/2019-07-05-hexo博客优化-gulp压缩-提高访问速度.html"},{"title":"webpack入门(1): 核心概念","text":"介绍webpack 是一个用于编译Javascript模块的工具，在安装webpack之后，可以通过 CLI (command line interface 就是在控制台上使用 ) API (在js中导入模块使用) 在使用webpack之前，如果你还是一个新手，请阅读下面的核心概念之后，再进行操作 如果你想直接进入操作来学习，请进入 webpack入门之安装与使用 核心概念webpack 本质上就是个 静态模块打包器(module bundler)。webpack处理程序时会创建依赖关系图，把你应用程序中用到的文件打包成一个或者多个文件 *这里可以了解更多关于 JavaScript 模块和 webpack 模块的信息* 从4.0.0版本之后，使用webpack不需要再创建一个配置文件 以下介绍几个核心概念 Entry (入口) Output (出口) Loaders Plugins (插件) Mode Browser Compatibility (浏览器兼容性) Entry 入口入口表示你的webpack打包开始的文件，它会寻找该文件依赖的其他文件，将他们合并打包。 可以通过webpack config中的entry属性，来定义一个（或者多个起点） 默认值为./src/index.js webpack.config.js 123module.exports = { entry: './path/to/my/entry/file.js'}; Output 出口即打包后完成文件输出的目录 默认输出js为./dist/main.js 其他文件在./dist webpack.config.js 1234567891011const path = require('path');module.exports = { entry: './path/to/my/entry/file.js', output: { /* 指定输出目录 */ path: path.resolve(__dirname, 'dist'), /* 指定输出文件名 */ filename: 'my-first-webpack.bundle.js' }}; 使用output.filename和output.path来指定文件名和路径 顶部引入的const path = require('path')是Node.js用于操作文件路径的模块 Loaderswebpack本身只能处理Javascript，使用loader可以让webpack让其他类型文件转换为webpack能够处理的模块 loader 能够import 导入任何类型的模块（例如.css 文件），这是 webpack 特有的功能 loader在webpack中配置如下 webpack.config.js 12345678910111213141516const path = require('path');const config = { output: { filename: 'my-first-webpack.bundle.js' }, module: { rules: [ /* test 正则表达式，用于匹配进行转换的文件 */ /* use 表示所使用的loader名称 */ { test: /\\.txt$/, use: 'raw-loader' } ] }};module.exports = config; 以上代码中添加了module，在内部定义了rules，里面必须包含 test 属性，(正则表达式) 用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，使用的loader名称 它们的作用是告诉webpack编译器，在解析时发现 import xxxx.txt / require(xxx.txt) 里面有.txt的路径时，使用raw-loader进行转换 Plugins 插件插件与Loader不同的是，插件可用于执行范围更广的任务，具体是什么个东西在使用webpack之后就会渐渐了解 Plugins的配置如下 12345678910111213141516const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const config = { module: { rules: [ { test: /\\.txt$/, use: 'raw-loader' } ] }, plugins: [ /* 实例化一个对象 */ new HtmlWebpackPlugin({template: './src/index.html'}) ]};module.exports = config; 这里使用了一个叫做html-webpack-plugin的插件 首先在config里添加 123456const config = { /* ... */ plugins: [ /* ... */ ]}; 然后导入HtmlWebpackPlugin插件 1const HtmlWebpackPlugin = require('html-webpack-plugin'); 在config里new 一个实例 12345const config = { plugins: [ new HtmlWebpackPlugin({template: './src/index.html'}) ]}; 模式webpack有两种模式 development production 及开发模式和生产模式了解更多 浏览器兼容性webpack 支持所有支持ES5的浏览器(IE8 及以下不支持)如果你想支持旧版浏览器，你需要加载polyfill","link":"/blog/articles/2019-07-16-webpack-tutorial-01.html"},{"title":"webpack入门(2): 安装与使用","text":"下面就来通过例子讲解webpack的安装，基本操作 webpack 是一个用于编译Javascript模块的工具，在安装webpack之后，可以通过 CLI (command line interface 就是在控制台上使用 ) API (在js中导入模块使用) 下面介绍的是webpack-cli的使用 安装输入下面指令，意思是 创建webpack-demo文件夹 进入webpack-demo 初始化npm -y参数表示自动输入yes 安装webpack 安装webpack-cli 12345mkdir webpack-democd webpack-demonpm init -ynpm install webpack --save-devnpm install webpack-cli --save-dev 执行完之后会生成一个package.json，这是npm生成的文件，定义了这个项目所需要的各种模块,以及项目的配置信息。关于npm和package.json这里不做过多阐述 如果你想要了解 package.json 内在机制的更多信息，推荐阅读 npm 文档。 创建文件创建以下目录结构 12345 webpack-demo |- package.json+ |- index.html+ |- /src+ |- index.js 各个文件的内容如下./src/index.js 12345678910function component() { const element = document.createElement('div'); // Lodash（目前通过一个 script 脚本引入）对于执行这一行是必需的 element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element;}document.body.appendChild(component()); ./index.html 12345678910&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;script src=\"https://unpkg.com/lodash@4.16.6\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"./src/index.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ./package.json 123456789101112131415161718 { \"name\": \"webpack-demo\", \"version\": \"1.0.0\", \"description\": \"\",+ \"private\": true, - \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"webpack\": \"^4.20.2\", \"webpack-cli\": \"^3.1.2\" }, \"dependencies\": {} } private的作用是防止项目被发布 在开始使用webpack前，观察目录结构，默认情况下webpack的入口是src/index.js，index.js的执行需要依赖lodash 这在index.html体现出来， 1&lt;script src=\"https://unpkg.com/lodash@4.16.6\"&gt;&lt;/script&gt; 在index.js引入之前引入了lodash 但index.js未显式声明引入lodash，这时webpack会假定存在全局变量 _ lodash这个库的使用方式就是用 _操作，与jquery的$类似 不过这样做会有一些问题 无法立即体现，脚本的执行依赖于外部扩展库(external library)。 如果依赖不存在，或者引入顺序错误，应用程序将无法正常运行。 如果依赖被引入但是并没有使用，浏览器将被迫下载无用代码。 这时候执行 这句话意思是，执行安装在node_module的webpack控制台程序 1npx webpack 生成的文件中不会有lodash的变量_，将会报错 下面src/index.js通过webpack打包后生成的文件，默认在dist目录下 这里只有main.js 通过查看里面也没有lodash的脚本 index.html也不存在 显然我们这不是我们预期的输出 调整这里需要手动将index.html移入dist文件夹 更改script标签 123456789&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;起步&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这里删除了两个script标签，引入了main.js 1234567891011 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Getting Started&lt;/title&gt;- &lt;script src=\"https://unpkg.com/lodash@4.16.6\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;- &lt;script src=\"./src/index.js\"&gt;&lt;/script&gt;+ &lt;script src=\"main.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 不过这里的main.js仍然没有引入lodash 这时候执行 1npx webpack 访问index.html查看控制台 可以看出 _没有被定义 通过npm安装lodash并通过import引入通过npm 安装lodash 1npm install --save lodash 引入到index.js 只是在第一行增加了import _ from 'lodash'; 123456789101112import _ from 'lodash';function component() { var element = document.createElement('div'); // Lodash 通过import引入 element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element; } document.body.appendChild(component()); 现在，可以打包我们的程序了 1npx webpack 执行安装在node_module的webpack控制台程序 查看页面 这说明代码已经执行，现在已经没问题了 使用配置文件这时我们已经基本了解webpack的工作流程，不过大多数情况下，都要通过webpack.config.js配置文件来控制webpack文件的入口，出口，需要用到的loader、插件 该内容将在下一章进行讲解","link":"/blog/articles/2019-07-16-webpack-tutorial-02-getting-start.html"},{"title":"webpack入门(4): loader的使用，css-loader","text":"更新中 webpack 的核心就是将资源文件打包，通过前面两章只对 webpack 进行初步的学习，也知道了如何对单个 javascript 文件进行打包，不过如果项目中包含css文件，也需要对其进行打包。 当然css可以不用打包，但是命名空间会成为问题，很多css融在一起难免会造成命名冲突，所以才会有vue、react这些框架的组件化编程思想 组件化的核心思想就是将css、javascript、html组合成一个单独的小部件，比如你做了一个相册，将代码分别写在html、css、javacript里面，当别人要用这个相册的时候就遇到问题了： 需要复制你的html相册部分元素 需要复制你的javascript 需要复制你的css样式表 在自己的工程中引入css和js 祈祷css、javascript中没有冲突 好的做法 将css、html、javascript融合到一个javascript文件作为一个模块，使用javascript生成css、html，然后别人只需要这样做： 假定这个javascript文件叫做album.js 引入album.js到&lt;script&gt;&lt;/script&gt;标签或者使用模块的方式引入到你的javascript里面 使用内部的方法，比如new album(selector) 然后就在对应的元素上创建了相册 说了这么多，下面就来学习在webpack中如何使用css-loader对css进行打包 准备工作安装安装style-loader和css-loader 12npm install --save-dev style-loader npm install --save-dev css-loader 添加文件为了做演示，这里写了一个简单的css文件 12345678910* { padding: 0; margin: 0;}body { background: darkblue; height: 100vh;}","link":"/blog/articles/2019-07-17-webpack-tutorial-04-use-cssloader.html"},{"title":"webpack入门(3): 使用配置文件webpack.config.js及多入口的配置","text":"如果想修改webpack的默认入口，出口，使用的插件，loader时，可以通过控制台的webpack指令传入参数 如 1webpack --entry xxxx 来定义入口文件 但是更多的做法是创建一个webpack.config.js文件，利用这个文件对进行相关的配置 下面介绍使用webpack.config.js的基本配置以及多 使用webpack.config.js创建方式 可以手动新建文件， 也可以使用npx webpack init指令初始化配置文件 使用npx webpack init命令 在输入指令后根据提示创建配置文件 1234567891011npx webpack initi INFO For more information and a detailed description of each question, have a look at: https://github.com/webpack/webpack-cli/blob/master/INIT.mdi INFO Alternatively, run \"webpack(-cli) --help\" for usage info? Will your application have multiple bundles? No? Which will be your application entry point? src/index? In which folder do you want to store your generated bundles? dist? Will you use one of the below JS solutions? ES6? Will you use one of the below CSS solutions? CSS? Overwrite src\\index.js? overwrite 手动创建webpack.config.js 在项目根目录创建webpack.config.js 编辑文件 webpack.config.js 使用module.exports暴露模块 entry 定义入口文件 output 定义输出文件 plugins 使用的插件 module 使用的loader 12345678910111213141516171819202122232425262728const path = require('path');module.exports = { // 使用开发者模式 mode: 'development', // 定义入口 entry: './src/index.js', // 定义输出文件 output: { filename: 'main.js', path: path.resolve(__dirname, 'dist') }, /* // 定义插件 plugins: [new webpack.ProgressPlugin(), new HtmlWebpackPlugin()], // 定义loader module: { rules: [ { test: /\\.css$/i, use: ['style-loader', 'css-loader'], }, ], }, */}; 配置好之后运行npx webpack 输出 配置多个入口入口 这里使用3个js文件 webpack.config.js 12345678910111213module.exports = { // 使用对象语法定义3个入口文件 entry: { pageOne: './src/index1.js', pageTwo: './src/index2.js', pageThree: './src/index3.js' }, // 分别输出3个js文件，[name]表示对应的文件名 output: { filename: '[name].js', path: __dirname + '/dist' }}; 运行npx webpack 输出","link":"/blog/articles/2019-07-16-webpack-tutorial-03-config.html"},{"title":"ES6新特性之Map、Set与WeakMap、WeakSet的区别","text":"ES6提供了新的数据结构Set，类似于数组，不过里面不会出现重复的值 另外一个是Map，类似于对象，对象只能使用字符串作为键，而Map可以使用任意类型 回顾下Map和Set 简要总结如下： Map 与 Object 一样，本质上是Hash结构 可以使用各种类型作为key Object 只能使用字符串作为key 如： 12345678910111213// 使用数组作为keylet o = [1,2,3]let b = [1,2,3]let map = new Map()map.set(o, 'foo')map.set(b, 'bar')// 虽然使用了相同的数组，但数组的内存地址不一样，所以key不一样console.log(map.get(o)) // 'foo'console.log(map.get(b)) // 'bar'// 而使用对象就不能用上面的方法，对象的key只能使用字符串let obj = { [1,2,3]: 'foo' //会报语法错误} Set 与数组类似 成员唯一，没有重复值 12345678910let set = new Set([1,1,1,2,3,4])for (let item of set) { console.log(item)}// 1// 2// 3// 4// 去掉了重复的1 WeakMap和WeakSet与Map和Set的主要区别就是： WeakSet 对象中只能存放对象引用，不能存放原始数据（如数字 1) WeakSet 对象中存储的对象值都是被弱引用的，如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉。 WeakMap 中的key只是对象引用，不能是 原始数据类型 WeakMap 持有的是每个键或值对象的弱引用，如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉。 WeakMap 的key/和 WeakSet 的元素是不可枚举的，因为他们存储的对象都是被弱引用的，如果能被枚举，会受垃圾回收机制的影响出现不确定性的结果","link":"/blog/articles/2019-07-26-WeakSet-WeakMap.html"},{"title":"CSS动画-auto属性的过渡","text":"通常，你想要通过css transition来过渡属性，然后使用了下面代码transition: height 0.5s linear 然后又使用了 height: auto来自适应高度height: 0 -&gt; height: auto 然后发现动画就像没发生一样，直接就在0和auto两个状态之间直接切换 你可能会认为出现了什么bug，或者代码写错了，其实不然 你可能发生下图所示的情况 在这篇文章中，都使用高度进行说明，这张图里的宽度与高度是一个道理 这个问题目前还不能简单通过css完全解决 下面是我分享的4个解决方案 本文章部分资料以及Code Pen代码引用于 css-tricks.com， 里面有很多关于css的技巧，值得学习 这是浏览器bug?查阅Mozilla Developer Network docs， auto 属性值被排除在transition规范之外。 这样做的原因是因为，如果transition一个元素的高度到auto，浏览器将会进行页面重排(reflow)，重排页面会计算其他元素的位置，并且在每一个动画帧都会进行这样的操作，这意味着将花费巨大的开销。 虽然设置height: auto达到不了我们想要的效果，但是可以通过其他方法实现，下面介绍4种方式 使用max-height 使用transform: scaleY() 使用Javascript 使用Flex容器 解决方案 1: 使用 max-height这个方法可能是最容易搜索到的方法，但是不太理想，不过在一些情况下，还是值得使用 具体方法大概如下： ​ 设置 transition: max-height 0.3s ease-out ​ max-height: 0 ​ 过渡到一个该容器能达到的最大值，比如 1000px ​ max-height: 1000px 这里的max-height必须保证大于容器auto的height，不然就会出现内容显示不全的情况 Code Pen演示 在以下的code pen演示中都使用的SCSS，如果需查看CSS，请点击下面的View Compiled按钮 主要注意.section这部分 123456789.section { overflow:hidden; transition:max-height 0.3s ease-out; /* 设置max-height的transition属性 */ height:auto; max-height:600px; /* 这里仍然需要硬编码 */}.section.collapsed { max-height:0;} See the Pen Smooth Collapsing div with max-height by Chen Yinyi (@CYSILVER) on CodePen. 缺点可能你也发现了，这里的max-height也是硬编码，大多数情况下也不好确定容器的最大内容高度。 其次，设置的transition的时间和变换函数和实际展示出来的并不一致 打个比方 ​ 内容的实际最高宽度为100px ​ 你设置了: ​ max-height: 0 -&gt; max-height: 1000px ​ transition: max-height 10s linear; ​ 那么这里的10s的transition显示在浏览器上就只有1s，因为1s后max-height: 100px已经达到容器最大高度，后面的max-height的变化不会体现出来 ​ 解决方案 2: transform: scaleY()该方法不会触发页面重排(reflow) 设置方法很简单 设置 transform: scaleY(0) 到 transform: scaleY(1) 即可完成高度的缩放 该方法不会触发重排，所以元素位置不会改变，同时元素的内容会产生挤压的形变效果 Code Pen 演示12345678910.section { overflow:hidden; transition:transform 0.3s ease-out; /* 设置transform的transition属性 */ height:auto; transform:scaleY(1); /* 可以不用显示声明，但最好的做法是在这里声明一下 */ transform-origin:top; /* 设置transform的起始点，不然就会从中间开始缩放 */}.section.collapsed { transform:scaleY(0); /* 设置为0 */} See the Pen Smooth Collapsing div with scaleY() by Chen Yinyi (@CYSILVER) on CodePen. 缺点该方法普遍不适用 产生的形变效果大部分时候不是我们想要的，也不够没关 不会产生页面重排，折叠后的位置留空，大部分时候不是我们想要的情况 解决方案 3: Javascript（推荐）该方法使用js获取到内容的最大高度，然后就能使用固定的高度进行transition了 基本思路是使用，获取到元素的高度 1element.scrollHeight 然后设置 1element.style.height = scrollHeight 点击后设置 1element.style.height = 0 这样就能实现css的transition效果，并且移除了硬编码，更加灵活，适用于任意高度的容器 Code Pen 演示要点在这两部分 12var sectionHeight = element.scrollHeight; // 获取到内容的高度element.style.height = sectionHeight + 'px'; // 设置Height 关于scrollHeight Element.scrollHeight 这个只读属性是一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容。 我这里放个图大家就知道了 See the Pen Smooth Collapsing div with Javascript by Chen Yinyi (@CYSILVER) on CodePen. 这里使用到了requestAnimationFrame()，关于这个我会在之后的博文讲解。 下面是我写的另外一种做法，比这个要直观一点 12345678910111213141516171819document.querySelectorAll('.dropdown-nav__title').forEach((item, index) =&gt; { item.addEventListener( 'click', (function(event) { // 利用闭包存储状态 let opened = false return function(event) { let scrollHeight = event.target.nextElementSibling.scrollHeight requestAnimationFrame(() =&gt; { // 切换height event.target.nextElementSibling.style.height = opened ? '0' : `${scrollHeight}px` opened = !opened }) } })() //立即执行函数，返回内部的function ) }) See the Pen dropDown-menu by Chen Yinyi (@CYSILVER) on CodePen. 缺点同样的，这里没有避免掉页面重排的问题 不过在某些特定的情况下，可以通过使用绝对定位来避免页面重排，比如导航栏的下拉菜单如果需要设置动画，就不需要重排页面。 解决方案 4: FlexBox (额外方式)之所以称之为额外方式，是因为从技术上来说该方式没有达到预期的效果，不过却是另外一种不错的方法 如果你还不够了解flexbox 和 flex-grow两个属性，推荐阅读 阮一峰的Flex 布局教程 A Complete Guide to FlexBox (英文) 这里的话主要就是用到的flex这个属性了(实质上为flex-grow) Code Pen 演示123456789.section { overflow:hidden; /* 注意这里是关键 */ transition:flex 0.3s ease-out; /* 设置flex的transition */ height:auto; flex:1; /* 设置flex为1，或者1以上，即容器能够自动伸长，关于这个值的作用请见flexbox的教程 */}.section.collapsed { flex: 0; /* 设置flex为0，即容器不会自动伸长 */} 请注意上面的 1overflow: hidden; 这句话是关键，可替换为 1min-height: 0; 因为默认情况下，元素不会缩短至小于内容框尺寸，若想改变这一状况，请设置元素的min-width与 min-height属性。同样的设置overflow: hidden也可达到相同效果 See the Pen Smooth Collapsing div with Flexbox by Chen Yinyi (@CYSILVER) on CodePen. 这又是另一种效果，所以说是一种额外的解决方法。 不过这种方法利用了flexbox，更加灵活 总结这四种方式各有优缺点，没有优劣，不过个人还是比较喜欢用js的方式，不过至于到底该用哪个，根据你的需求和情况而定。","link":"/blog/articles/2019-07-14-CSS动画-auto属性的过渡.html"}],"tags":[{"name":"javascript","slug":"javascript","link":"/blog/tags/javascript/"},{"name":"dom","slug":"dom","link":"/blog/tags/dom/"},{"name":"html","slug":"html","link":"/blog/tags/html/"},{"name":"css","slug":"css","link":"/blog/tags/css/"},{"name":"js","slug":"js","link":"/blog/tags/js/"},{"name":"bug","slug":"bug","link":"/blog/tags/bug/"},{"name":"vim","slug":"vim","link":"/blog/tags/vim/"},{"name":"vscode","slug":"vscode","link":"/blog/tags/vscode/"},{"name":"gulp","slug":"gulp","link":"/blog/tags/gulp/"},{"name":"博客优化","slug":"博客优化","link":"/blog/tags/博客优化/"},{"name":"webpack","slug":"webpack","link":"/blog/tags/webpack/"},{"name":"es6","slug":"es6","link":"/blog/tags/es6/"},{"name":"animation","slug":"animation","link":"/blog/tags/animation/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/blog/categories/javascript/"},{"name":"前端","slug":"前端","link":"/blog/categories/前端/"},{"name":"github","slug":"github","link":"/blog/categories/github/"},{"name":"webpack系列教程","slug":"前端/webpack系列教程","link":"/blog/categories/前端/webpack系列教程/"},{"name":"布局","slug":"前端/布局","link":"/blog/categories/前端/布局/"},{"name":"es6","slug":"前端/es6","link":"/blog/categories/前端/es6/"},{"name":"gulp","slug":"前端/gulp","link":"/blog/categories/前端/gulp/"},{"name":"css动画","slug":"css动画","link":"/blog/categories/css动画/"}]}